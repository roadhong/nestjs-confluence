/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { HttpService } from "@nestjs/axios";
import { Injectable, Optional } from "@nestjs/common";
import type { AxiosRequestConfig, AxiosResponse } from "axios";
import { Observable, from, of, switchMap } from "rxjs";
import { Configuration } from "../configuration";
import { BlogPostSortOrder } from "../model/blogPostSortOrder";
import { CreateBlogPost200Response } from "../model/createBlogPost200Response";
import { CreateBlogPostRequest } from "../model/createBlogPostRequest";
import { MultiEntityResultBlogPost } from "../model/multiEntityResultBlogPost";
import { PrimaryBodyRepresentation } from "../model/primaryBodyRepresentation";
import { PrimaryBodyRepresentationSingle } from "../model/primaryBodyRepresentationSingle";
import { UpdateBlogPostRequest } from "../model/updateBlogPostRequest";

@Injectable()
export class BlogPostService {
  protected basePath = "https://no-default/wiki/api/v2";
  public defaultHeaders: Record<string, string> = {};
  public configuration = new Configuration();
  protected httpClient: HttpService;

  constructor(
    httpClient: HttpService,
    @Optional() configuration: Configuration,
  ) {
    this.configuration = configuration || this.configuration;
    this.basePath = configuration?.basePath || this.basePath;
    this.httpClient = configuration?.httpClient || httpClient;
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = "multipart/form-data";
    return consumes.includes(form);
  }

  /**
   * Create blog post
   * Creates a new blog post in the space specified by the spaceId.  By default this will create the blog post as a non-draft, unless the status is specified as draft. If creating a non-draft, the title must not be empty.  Currently only supports the storage representation specified in the body.representation enums below
   * @param createBlogPostRequest
   * @param _private The blog post will be private. Only the user who creates this blog post will have permission to view and edit one.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createBlogPostOpts.config] Override http request option.
   */
  public createBlogPost(
    createBlogPostRequest: CreateBlogPostRequest,
    _private?: boolean,
    createBlogPostOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<CreateBlogPost200Response>>;
  public createBlogPost(
    createBlogPostRequest: CreateBlogPostRequest,
    _private?: boolean,
    createBlogPostOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (createBlogPostRequest === null || createBlogPostRequest === undefined) {
      throw new Error(
        "Required parameter createBlogPostRequest was null or undefined when calling createBlogPost.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (_private !== undefined && _private !== null) {
      queryParameters.append("private", <any>_private);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<CreateBlogPost200Response>(
          `${this.basePath}/blogposts`,
          createBlogPostRequest,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...createBlogPostOpts?.config,
            headers: { ...headers, ...createBlogPostOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Delete blog post
   * Delete a blog post by id.  By default this will delete blog posts that are non-drafts. To delete a blog post that is a draft, the endpoint must be called on a  draft with the following param &#x60;draft&#x3D;true&#x60;. Discarded drafts are not sent to the trash and are permanently deleted.  Deleting a blog post that is not a draft moves the blog post to the trash, where it can be restored later. To permanently delete a blog post (or \&quot;purge\&quot; it), the endpoint must be called on a **trashed** blog post with the following param &#x60;purge&#x3D;true&#x60;.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the blog post and its corresponding space. Permission to delete blog posts in the space. Permission to administer the space (if attempting to purge).
   * @param id The ID of the blog post to be deleted.
   * @param purge If attempting to purge the blog post.
   * @param draft If attempting to delete a blog post that is a draft.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteBlogPostOpts.config] Override http request option.
   */
  public deleteBlogPost(
    id: number,
    purge?: boolean,
    draft?: boolean,
    deleteBlogPostOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteBlogPost(
    id: number,
    purge?: boolean,
    draft?: boolean,
    deleteBlogPostOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling deleteBlogPost.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (purge !== undefined && purge !== null) {
      queryParameters.append("purge", <any>purge);
    }
    if (draft !== undefined && draft !== null) {
      queryParameters.append("draft", <any>draft);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/blogposts/${encodeURIComponent(String(id))}`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...deleteBlogPostOpts?.config,
            headers: { ...headers, ...deleteBlogPostOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Get blog post by id
   * Returns a specific blog post.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the blog post and its corresponding space.
   * @param id The ID of the blog post to be returned. If you don\&#39;t know the blog post ID, use Get blog posts and filter the results.
   * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param getDraft Retrieve the draft version of this blog post.
   * @param status Filter the blog post being retrieved by its status.
   * @param version Allows you to retrieve a previously published version. Specify the previous version\&#39;s number to retrieve its details.
   * @param includeLabels Includes labels associated with this blog post in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeProperties Includes content properties associated with this blog post in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeOperations Includes operations associated with this blog post in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeLikes Includes likes associated with this blog post in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeVersions Includes versions associated with this blog post in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeVersion Includes the current version associated with this blog post in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
   * @param includeFavoritedByCurrentUserStatus Includes whether this blog post has been favorited by the current user.
   * @param includeWebresources Includes web resources that can be used to render blog post content on a client.
   * @param includeCollaborators Includes collaborators on the blog post.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getBlogPostByIdOpts.config] Override http request option.
   */
  public getBlogPostById(
    id: number,
    bodyFormat?: PrimaryBodyRepresentationSingle,
    getDraft?: boolean,
    status?: Array<"current" | "trashed" | "deleted" | "historical" | "draft">,
    version?: number,
    includeLabels?: boolean,
    includeProperties?: boolean,
    includeOperations?: boolean,
    includeLikes?: boolean,
    includeVersions?: boolean,
    includeVersion?: boolean,
    includeFavoritedByCurrentUserStatus?: boolean,
    includeWebresources?: boolean,
    includeCollaborators?: boolean,
    getBlogPostByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<CreateBlogPost200Response>>;
  public getBlogPostById(
    id: number,
    bodyFormat?: PrimaryBodyRepresentationSingle,
    getDraft?: boolean,
    status?: Array<"current" | "trashed" | "deleted" | "historical" | "draft">,
    version?: number,
    includeLabels?: boolean,
    includeProperties?: boolean,
    includeOperations?: boolean,
    includeLikes?: boolean,
    includeVersions?: boolean,
    includeVersion?: boolean,
    includeFavoritedByCurrentUserStatus?: boolean,
    includeWebresources?: boolean,
    includeCollaborators?: boolean,
    getBlogPostByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getBlogPostById.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (getDraft !== undefined && getDraft !== null) {
      queryParameters.append("get-draft", <any>getDraft);
    }
    if (status) {
      status.forEach((element) => {
        queryParameters.append("status", <any>element);
      });
    }
    if (version !== undefined && version !== null) {
      queryParameters.append("version", <any>version);
    }
    if (includeLabels !== undefined && includeLabels !== null) {
      queryParameters.append("include-labels", <any>includeLabels);
    }
    if (includeProperties !== undefined && includeProperties !== null) {
      queryParameters.append("include-properties", <any>includeProperties);
    }
    if (includeOperations !== undefined && includeOperations !== null) {
      queryParameters.append("include-operations", <any>includeOperations);
    }
    if (includeLikes !== undefined && includeLikes !== null) {
      queryParameters.append("include-likes", <any>includeLikes);
    }
    if (includeVersions !== undefined && includeVersions !== null) {
      queryParameters.append("include-versions", <any>includeVersions);
    }
    if (includeVersion !== undefined && includeVersion !== null) {
      queryParameters.append("include-version", <any>includeVersion);
    }
    if (
      includeFavoritedByCurrentUserStatus !== undefined &&
      includeFavoritedByCurrentUserStatus !== null
    ) {
      queryParameters.append(
        "include-favorited-by-current-user-status",
        <any>includeFavoritedByCurrentUserStatus,
      );
    }
    if (includeWebresources !== undefined && includeWebresources !== null) {
      queryParameters.append("include-webresources", <any>includeWebresources);
    }
    if (includeCollaborators !== undefined && includeCollaborators !== null) {
      queryParameters.append(
        "include-collaborators",
        <any>includeCollaborators,
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<CreateBlogPost200Response>(
          `${this.basePath}/blogposts/${encodeURIComponent(String(id))}`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getBlogPostByIdOpts?.config,
            headers: { ...headers, ...getBlogPostByIdOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Get blog posts
   * Returns all blog posts. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission). Only blog posts that the user has permission to view will be returned.
   * @param id Filter the results based on blog post ids. Multiple blog post ids can be specified as a comma-separated list.
   * @param spaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
   * @param sort Used to sort the result by a particular field.
   * @param status Filter the results to blog posts based on their status. By default, &#x60;current&#x60; is used.
   * @param title Filter the results to blog posts based on their title.
   * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; response header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getBlogPostsOpts.config] Override http request option.
   */
  public getBlogPosts(
    id?: Array<number>,
    spaceId?: Array<number>,
    sort?: BlogPostSortOrder,
    status?: Array<"current" | "deleted" | "trashed">,
    title?: string,
    bodyFormat?: PrimaryBodyRepresentation,
    cursor?: string,
    limit?: number,
    getBlogPostsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultBlogPost>>;
  public getBlogPosts(
    id?: Array<number>,
    spaceId?: Array<number>,
    sort?: BlogPostSortOrder,
    status?: Array<"current" | "deleted" | "trashed">,
    title?: string,
    bodyFormat?: PrimaryBodyRepresentation,
    cursor?: string,
    limit?: number,
    getBlogPostsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    let queryParameters = new URLSearchParams();
    if (id) {
      id.forEach((element) => {
        queryParameters.append("id", <any>element);
      });
    }
    if (spaceId) {
      spaceId.forEach((element) => {
        queryParameters.append("space-id", <any>element);
      });
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (status) {
      status.forEach((element) => {
        queryParameters.append("status", <any>element);
      });
    }
    if (title !== undefined && title !== null) {
      queryParameters.append("title", <any>title);
    }
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultBlogPost>(
          `${this.basePath}/blogposts`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getBlogPostsOpts?.config,
            headers: { ...headers, ...getBlogPostsOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Get blog posts in space
   * Returns all blog posts in a space. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and view the space. Only blog posts that the user has permission to view will be returned.
   * @param id The ID of the space for which blog posts should be returned.
   * @param sort Used to sort the result by a particular field.
   * @param status Filter the results to blog posts based on their status. By default, &#x60;current&#x60; is used.
   * @param title Filter the results to blog posts based on their title.
   * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getBlogPostsInSpaceOpts.config] Override http request option.
   */
  public getBlogPostsInSpace(
    id: number,
    sort?: BlogPostSortOrder,
    status?: Array<"current" | "deleted" | "trashed">,
    title?: string,
    bodyFormat?: PrimaryBodyRepresentation,
    cursor?: string,
    limit?: number,
    getBlogPostsInSpaceOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultBlogPost>>;
  public getBlogPostsInSpace(
    id: number,
    sort?: BlogPostSortOrder,
    status?: Array<"current" | "deleted" | "trashed">,
    title?: string,
    bodyFormat?: PrimaryBodyRepresentation,
    cursor?: string,
    limit?: number,
    getBlogPostsInSpaceOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getBlogPostsInSpace.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (status) {
      status.forEach((element) => {
        queryParameters.append("status", <any>element);
      });
    }
    if (title !== undefined && title !== null) {
      queryParameters.append("title", <any>title);
    }
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultBlogPost>(
          `${this.basePath}/spaces/${encodeURIComponent(String(id))}/blogposts`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getBlogPostsInSpaceOpts?.config,
            headers: {
              ...headers,
              ...getBlogPostsInSpaceOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get blog posts for label
   * Returns the blogposts of specified label. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
   * @param id The ID of the label for which blog posts should be returned.
   * @param spaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
   * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of blog posts per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getLabelBlogPostsOpts.config] Override http request option.
   */
  public getLabelBlogPosts(
    id: number,
    spaceId?: Array<number>,
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: BlogPostSortOrder,
    cursor?: string,
    limit?: number,
    getLabelBlogPostsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultBlogPost>>;
  public getLabelBlogPosts(
    id: number,
    spaceId?: Array<number>,
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: BlogPostSortOrder,
    cursor?: string,
    limit?: number,
    getLabelBlogPostsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getLabelBlogPosts.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (spaceId) {
      spaceId.forEach((element) => {
        queryParameters.append("space-id", <any>element);
      });
    }
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultBlogPost>(
          `${this.basePath}/labels/${encodeURIComponent(String(id))}/blogposts`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getLabelBlogPostsOpts?.config,
            headers: { ...headers, ...getLabelBlogPostsOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Update blog post
   * Update a blog post by id.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the blog post and its corresponding space. Permission to update blog posts in the space.
   * @param id The ID of the blog post to be updated. If you don\&#39;t know the blog post ID, use Get Blog Posts and filter the results.
   * @param updateBlogPostRequest
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateBlogPostOpts.config] Override http request option.
   */
  public updateBlogPost(
    id: number,
    updateBlogPostRequest: UpdateBlogPostRequest,
    updateBlogPostOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<CreateBlogPost200Response>>;
  public updateBlogPost(
    id: number,
    updateBlogPostRequest: UpdateBlogPostRequest,
    updateBlogPostOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling updateBlogPost.",
      );
    }

    if (updateBlogPostRequest === null || updateBlogPostRequest === undefined) {
      throw new Error(
        "Required parameter updateBlogPostRequest was null or undefined when calling updateBlogPost.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<CreateBlogPost200Response>(
          `${this.basePath}/blogposts/${encodeURIComponent(String(id))}`,
          updateBlogPostRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateBlogPostOpts?.config,
            headers: { ...headers, ...updateBlogPostOpts?.config?.headers },
          },
        );
      }),
    );
  }
}
