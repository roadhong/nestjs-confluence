/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { AttachmentSortOrder } from '../model/attachmentSortOrder';
import { GetAttachmentById200Response } from '../model/getAttachmentById200Response';
import { MultiEntityResultAttachment } from '../model/multiEntityResultAttachment';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class AttachmentService {

    protected basePath = 'https://no-default/wiki/api/v2';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Delete attachment
     * Delete an attachment by id.  Deleting an attachment moves the attachment to the trash, where it can be restored later. To permanently delete an attachment (or \&quot;purge\&quot; it), the endpoint must be called on a **trashed** attachment with the following param &#x60;purge&#x3D;true&#x60;.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the container of the attachment. Permission to delete attachments in the space. Permission to administer the space (if attempting to purge).
     * @param id The ID of the attachment to be deleted.
     * @param purge If attempting to purge the attachment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteAttachmentOpts.config] Override http request option.
     */
    public deleteAttachment(id: number, purge?: boolean, deleteAttachmentOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public deleteAttachment(id: number, purge?: boolean, deleteAttachmentOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAttachment.');
        }

        let queryParameters = new URLSearchParams();
        if (purge !== undefined && purge !== null) {
            queryParameters.append('purge', <any>purge);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/attachments/${encodeURIComponent(String(id))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...deleteAttachmentOpts?.config,
                        headers: {...headers, ...deleteAttachmentOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get attachment by id
     * Returns a specific attachment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the attachment\&#39;s container.
     * @param id The ID of the attachment to be returned. If you don\&#39;t know the attachment\&#39;s ID, use Get attachments for page/blogpost/custom content.
     * @param version Allows you to retrieve a previously published version. Specify the previous version\&#39;s number to retrieve its details.
     * @param includeLabels Includes labels associated with this attachment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeProperties Includes content properties associated with this attachment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeOperations Includes operations associated with this attachment in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeVersions Includes versions associated with this attachment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeVersion Includes the current version associated with this attachment in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
     * @param includeCollaborators Includes collaborators on the attachment.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getAttachmentByIdOpts.config] Override http request option.
     */
    public getAttachmentById(id: string, version?: number, includeLabels?: boolean, includeProperties?: boolean, includeOperations?: boolean, includeVersions?: boolean, includeVersion?: boolean, includeCollaborators?: boolean, getAttachmentByIdOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<GetAttachmentById200Response>>;
    public getAttachmentById(id: string, version?: number, includeLabels?: boolean, includeProperties?: boolean, includeOperations?: boolean, includeVersions?: boolean, includeVersion?: boolean, includeCollaborators?: boolean, getAttachmentByIdOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAttachmentById.');
        }

        let queryParameters = new URLSearchParams();
        if (version !== undefined && version !== null) {
            queryParameters.append('version', <any>version);
        }
        if (includeLabels !== undefined && includeLabels !== null) {
            queryParameters.append('include-labels', <any>includeLabels);
        }
        if (includeProperties !== undefined && includeProperties !== null) {
            queryParameters.append('include-properties', <any>includeProperties);
        }
        if (includeOperations !== undefined && includeOperations !== null) {
            queryParameters.append('include-operations', <any>includeOperations);
        }
        if (includeVersions !== undefined && includeVersions !== null) {
            queryParameters.append('include-versions', <any>includeVersions);
        }
        if (includeVersion !== undefined && includeVersion !== null) {
            queryParameters.append('include-version', <any>includeVersion);
        }
        if (includeCollaborators !== undefined && includeCollaborators !== null) {
            queryParameters.append('include-collaborators', <any>includeCollaborators);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<GetAttachmentById200Response>(`${this.basePath}/attachments/${encodeURIComponent(String(id))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getAttachmentByIdOpts?.config,
                        headers: {...headers, ...getAttachmentByIdOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get attachments
     * Returns all attachments. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the container of the attachment.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param status Filter the results to attachments based on their status. By default, &#x60;current&#x60; and &#x60;archived&#x60; are used.
     * @param mediaType Filters on the mediaType of attachments. Only one may be specified.
     * @param filename Filters on the file-name of attachments. Only one may be specified.
     * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getAttachmentsOpts.config] Override http request option.
     */
    public getAttachments(sort?: AttachmentSortOrder, cursor?: string, status?: Array<'current' | 'archived' | 'trashed'>, mediaType?: string, filename?: string, limit?: number, getAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultAttachment>>;
    public getAttachments(sort?: AttachmentSortOrder, cursor?: string, status?: Array<'current' | 'archived' | 'trashed'>, mediaType?: string, filename?: string, limit?: number, getAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters.append('status', <any>element);
            })
        }
        if (mediaType !== undefined && mediaType !== null) {
            queryParameters.append('mediaType', <any>mediaType);
        }
        if (filename !== undefined && filename !== null) {
            queryParameters.append('filename', <any>filename);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultAttachment>(`${this.basePath}/attachments`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getAttachmentsOpts?.config,
                        headers: {...headers, ...getAttachmentsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get attachments for blog post
     * Returns the attachments of specific blog post. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the blog post and its corresponding space.
     * @param id The ID of the blog post for which attachments should be returned.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param status Filter the results to attachments based on their status. By default, &#x60;current&#x60; and &#x60;archived&#x60; are used.
     * @param mediaType Filters on the mediaType of attachments. Only one may be specified.
     * @param filename Filters on the file-name of attachments. Only one may be specified.
     * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getBlogpostAttachmentsOpts.config] Override http request option.
     */
    public getBlogpostAttachments(id: number, sort?: AttachmentSortOrder, cursor?: string, status?: Array<'current' | 'archived' | 'trashed'>, mediaType?: string, filename?: string, limit?: number, getBlogpostAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultAttachment>>;
    public getBlogpostAttachments(id: number, sort?: AttachmentSortOrder, cursor?: string, status?: Array<'current' | 'archived' | 'trashed'>, mediaType?: string, filename?: string, limit?: number, getBlogpostAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBlogpostAttachments.');
        }

        let queryParameters = new URLSearchParams();
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters.append('status', <any>element);
            })
        }
        if (mediaType !== undefined && mediaType !== null) {
            queryParameters.append('mediaType', <any>mediaType);
        }
        if (filename !== undefined && filename !== null) {
            queryParameters.append('filename', <any>filename);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultAttachment>(`${this.basePath}/blogposts/${encodeURIComponent(String(id))}/attachments`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getBlogpostAttachmentsOpts?.config,
                        headers: {...headers, ...getBlogpostAttachmentsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get attachments for custom content
     * Returns the attachments of specific custom content. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the custom content and its corresponding space.
     * @param id The ID of the custom content for which attachments should be returned.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param status Filter the results to attachments based on their status. By default, &#x60;current&#x60; and &#x60;archived&#x60; are used.
     * @param mediaType Filters on the mediaType of attachments. Only one may be specified.
     * @param filename Filters on the file-name of attachments. Only one may be specified.
     * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getCustomContentAttachmentsOpts.config] Override http request option.
     */
    public getCustomContentAttachments(id: number, sort?: AttachmentSortOrder, cursor?: string, status?: Array<'current' | 'archived' | 'trashed'>, mediaType?: string, filename?: string, limit?: number, getCustomContentAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultAttachment>>;
    public getCustomContentAttachments(id: number, sort?: AttachmentSortOrder, cursor?: string, status?: Array<'current' | 'archived' | 'trashed'>, mediaType?: string, filename?: string, limit?: number, getCustomContentAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomContentAttachments.');
        }

        let queryParameters = new URLSearchParams();
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters.append('status', <any>element);
            })
        }
        if (mediaType !== undefined && mediaType !== null) {
            queryParameters.append('mediaType', <any>mediaType);
        }
        if (filename !== undefined && filename !== null) {
            queryParameters.append('filename', <any>filename);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultAttachment>(`${this.basePath}/custom-content/${encodeURIComponent(String(id))}/attachments`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getCustomContentAttachmentsOpts?.config,
                        headers: {...headers, ...getCustomContentAttachmentsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get attachments for label
     * Returns the attachments of specified label. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the attachment and its corresponding space.
     * @param id The ID of the label for which attachments should be returned.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getLabelAttachmentsOpts.config] Override http request option.
     */
    public getLabelAttachments(id: number, sort?: AttachmentSortOrder, cursor?: string, limit?: number, getLabelAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultAttachment>>;
    public getLabelAttachments(id: number, sort?: AttachmentSortOrder, cursor?: string, limit?: number, getLabelAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLabelAttachments.');
        }

        let queryParameters = new URLSearchParams();
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultAttachment>(`${this.basePath}/labels/${encodeURIComponent(String(id))}/attachments`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getLabelAttachmentsOpts?.config,
                        headers: {...headers, ...getLabelAttachmentsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get attachments for page
     * Returns the attachments of specific page. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * @param id The ID of the page for which attachments should be returned.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param status Filter the results to attachments based on their status. By default, &#x60;current&#x60; and &#x60;archived&#x60; are used.
     * @param mediaType Filters on the mediaType of attachments. Only one may be specified.
     * @param filename Filters on the file-name of attachments. Only one may be specified.
     * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getPageAttachmentsOpts.config] Override http request option.
     */
    public getPageAttachments(id: number, sort?: AttachmentSortOrder, cursor?: string, status?: Array<'current' | 'archived' | 'trashed'>, mediaType?: string, filename?: string, limit?: number, getPageAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultAttachment>>;
    public getPageAttachments(id: number, sort?: AttachmentSortOrder, cursor?: string, status?: Array<'current' | 'archived' | 'trashed'>, mediaType?: string, filename?: string, limit?: number, getPageAttachmentsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPageAttachments.');
        }

        let queryParameters = new URLSearchParams();
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters.append('status', <any>element);
            })
        }
        if (mediaType !== undefined && mediaType !== null) {
            queryParameters.append('mediaType', <any>mediaType);
        }
        if (filename !== undefined && filename !== null) {
            queryParameters.append('filename', <any>filename);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultAttachment>(`${this.basePath}/pages/${encodeURIComponent(String(id))}/attachments`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getPageAttachmentsOpts?.config,
                        headers: {...headers, ...getPageAttachmentsOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
