/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { HttpService } from "@nestjs/axios";
import { Injectable, Optional } from "@nestjs/common";
import type { AxiosRequestConfig, AxiosResponse } from "axios";
import { Observable, from, of, switchMap } from "rxjs";
import { Configuration } from "../configuration";
import { MultiEntityResultAncestor } from "../model/multiEntityResultAncestor";
import { MultiEntityResultAncestor1 } from "../model/multiEntityResultAncestor1";

@Injectable()
export class AncestorsService {
  protected basePath = "https://no-default/wiki/api/v2";
  public defaultHeaders: Record<string, string> = {};
  public configuration = new Configuration();
  protected httpClient: HttpService;

  constructor(
    httpClient: HttpService,
    @Optional() configuration: Configuration,
  ) {
    this.configuration = configuration || this.configuration;
    this.basePath = configuration?.basePath || this.basePath;
    this.httpClient = configuration?.httpClient || httpClient;
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = "multipart/form-data";
    return consumes.includes(form);
  }

  /**
   * Get all ancestors of database
   * Returns all ancestors for a given database by ID in top-to-bottom order (that is, the highest ancestor is the first item in the response payload). The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.  This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such as [Get database by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-database/#api-databases-id-get).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission). Permission to view the database and its corresponding space
   * @param id The ID of the database.
   * @param limit Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor\&#39;s ID to fetch the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getDatabaseAncestorsOpts.config] Override http request option.
   */
  public getDatabaseAncestors(
    id: number,
    limit?: number,
    getDatabaseAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultAncestor>>;
  public getDatabaseAncestors(
    id: number,
    limit?: number,
    getDatabaseAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getDatabaseAncestors.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultAncestor>(
          `${this.basePath}/databases/${encodeURIComponent(
            String(id),
          )}/ancestors`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getDatabaseAncestorsOpts?.config,
            headers: {
              ...headers,
              ...getDatabaseAncestorsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get all ancestors of folder
   * Returns all ancestors for a given folder by ID in top-to-bottom order (that is, the highest ancestor is the first item in the response payload). The number of results is limited by the &#x60;limit&#x60; parameter and additional results  (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.  This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such as [Get folder by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-folders-id-get).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission). Permission to view the folder and its corresponding space
   * @param id The ID of the folder.
   * @param limit Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor\&#39;s ID to fetch the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getFolderAncestorsOpts.config] Override http request option.
   */
  public getFolderAncestors(
    id: number,
    limit?: number,
    getFolderAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultAncestor>>;
  public getFolderAncestors(
    id: number,
    limit?: number,
    getFolderAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getFolderAncestors.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultAncestor>(
          `${this.basePath}/folders/${encodeURIComponent(
            String(id),
          )}/ancestors`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getFolderAncestorsOpts?.config,
            headers: { ...headers, ...getFolderAncestorsOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Get all ancestors of page
   * Returns all ancestors for a given page by ID in top-to-bottom order (that is, the highest ancestor is the first item in the response payload). The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.  This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such as [Get page by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-page/#api-pages-id-get).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission).
   * @param id The ID of the page.
   * @param limit Maximum number of pages per result to return. If more results exist, call this endpoint with the highest ancestor\&#39;s ID to fetch the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getPageAncestorsOpts.config] Override http request option.
   */
  public getPageAncestors(
    id: number,
    limit?: number,
    getPageAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultAncestor1>>;
  public getPageAncestors(
    id: number,
    limit?: number,
    getPageAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getPageAncestors.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultAncestor1>(
          `${this.basePath}/pages/${encodeURIComponent(String(id))}/ancestors`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getPageAncestorsOpts?.config,
            headers: { ...headers, ...getPageAncestorsOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Get all ancestors of Smart Link in content tree
   * Returns all ancestors for a given Smart Link in the content tree by ID in top-to-bottom order (that is, the highest ancestor is the first item in the response payload). The number of results is limited by the &#x60;limit&#x60; parameter and additional results  (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.  This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such as [Get Smart Link in the content tree by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-smart-link/#api-embeds-id-get).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission). Permission to view the Smart Link in the content tree and its corresponding space
   * @param id The ID of the Smart Link in the content tree.
   * @param limit Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor\&#39;s ID to fetch the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getSmartLinkAncestorsOpts.config] Override http request option.
   */
  public getSmartLinkAncestors(
    id: number,
    limit?: number,
    getSmartLinkAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultAncestor>>;
  public getSmartLinkAncestors(
    id: number,
    limit?: number,
    getSmartLinkAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getSmartLinkAncestors.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultAncestor>(
          `${this.basePath}/embeds/${encodeURIComponent(String(id))}/ancestors`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getSmartLinkAncestorsOpts?.config,
            headers: {
              ...headers,
              ...getSmartLinkAncestorsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get all ancestors of whiteboard
   * Returns all ancestors for a given whiteboard by ID in top-to-bottom order (that is, the highest ancestor is the first item in the response payload). The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available by calling this endpoint with the ID of first ancestor in the response payload.  This endpoint returns minimal information about each ancestor. To fetch more details, use a related endpoint, such as [Get whiteboard by id](https://developer.atlassian.com/cloud/confluence/rest/v2/api-group-whiteboard/#api-whiteboards-id-get).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission). Permission to view the whiteboard and its corresponding space
   * @param id The ID of the whiteboard.
   * @param limit Maximum number of items per result to return. If more results exist, call the endpoint with the highest ancestor\&#39;s ID to fetch the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getWhiteboardAncestorsOpts.config] Override http request option.
   */
  public getWhiteboardAncestors(
    id: number,
    limit?: number,
    getWhiteboardAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultAncestor>>;
  public getWhiteboardAncestors(
    id: number,
    limit?: number,
    getWhiteboardAncestorsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getWhiteboardAncestors.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultAncestor>(
          `${this.basePath}/whiteboards/${encodeURIComponent(
            String(id),
          )}/ancestors`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getWhiteboardAncestorsOpts?.config,
            headers: {
              ...headers,
              ...getWhiteboardAncestorsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
}
