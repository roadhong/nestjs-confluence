/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { HttpService } from "@nestjs/axios";
import { Injectable, Optional } from "@nestjs/common";
import type { AxiosRequestConfig, AxiosResponse } from "axios";
import { Observable, from, of, switchMap } from "rxjs";
import { Configuration } from "../configuration";
import { ContentProperty } from "../model/contentProperty";
import { ContentPropertyCreateRequest } from "../model/contentPropertyCreateRequest";
import { ContentPropertySortOrder } from "../model/contentPropertySortOrder";
import { ContentPropertyUpdateRequest } from "../model/contentPropertyUpdateRequest";
import { MultiEntityResultContentProperty } from "../model/multiEntityResultContentProperty";

@Injectable()
export class ContentPropertiesService {
  protected basePath = "https://no-default/wiki/api/v2";
  public defaultHeaders: Record<string, string> = {};
  public configuration = new Configuration();
  protected httpClient: HttpService;

  constructor(
    httpClient: HttpService,
    @Optional() configuration: Configuration,
  ) {
    this.configuration = configuration || this.configuration;
    this.basePath = configuration?.basePath || this.basePath;
    this.httpClient = configuration?.httpClient || httpClient;
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = "multipart/form-data";
    return consumes.includes(form);
  }

  /**
   * Create content property for attachment
   * Creates a new content property for an attachment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the attachment.
   * @param attachmentId The ID of the attachment to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createAttachmentPropertyOpts.config] Override http request option.
   */
  public createAttachmentProperty(
    attachmentId: string,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createAttachmentPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createAttachmentProperty(
    attachmentId: string,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createAttachmentPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (attachmentId === null || attachmentId === undefined) {
      throw new Error(
        "Required parameter attachmentId was null or undefined when calling createAttachmentProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createAttachmentProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/attachments/${encodeURIComponent(
            String(attachmentId),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createAttachmentPropertyOpts?.config,
            headers: {
              ...headers,
              ...createAttachmentPropertyOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Create content property for blog post
   * Creates a new property for a blogpost.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the blog post.
   * @param blogpostId The ID of the blog post to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createBlogpostPropertyOpts.config] Override http request option.
   */
  public createBlogpostProperty(
    blogpostId: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createBlogpostPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createBlogpostProperty(
    blogpostId: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createBlogpostPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (blogpostId === null || blogpostId === undefined) {
      throw new Error(
        "Required parameter blogpostId was null or undefined when calling createBlogpostProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createBlogpostProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/blogposts/${encodeURIComponent(
            String(blogpostId),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createBlogpostPropertyOpts?.config,
            headers: {
              ...headers,
              ...createBlogpostPropertyOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Create content property for comment
   * Creates a new content property for a comment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the comment.
   * @param commentId The ID of the comment to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createCommentPropertyOpts.config] Override http request option.
   */
  public createCommentProperty(
    commentId: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createCommentPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createCommentProperty(
    commentId: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createCommentPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling createCommentProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createCommentProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/comments/${encodeURIComponent(
            String(commentId),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createCommentPropertyOpts?.config,
            headers: {
              ...headers,
              ...createCommentPropertyOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Create content property for custom content
   * Creates a new content property for a piece of custom content.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the custom content.
   * @param customContentId The ID of the custom content to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createCustomContentPropertyOpts.config] Override http request option.
   */
  public createCustomContentProperty(
    customContentId: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createCustomContentPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createCustomContentProperty(
    customContentId: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createCustomContentPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (customContentId === null || customContentId === undefined) {
      throw new Error(
        "Required parameter customContentId was null or undefined when calling createCustomContentProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createCustomContentProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/custom-content/${encodeURIComponent(
            String(customContentId),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createCustomContentPropertyOpts?.config,
            headers: {
              ...headers,
              ...createCustomContentPropertyOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Create content property for database
   * Creates a new content property for a database.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the database.
   * @param id The ID of the database to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createDatabasePropertyOpts.config] Override http request option.
   */
  public createDatabaseProperty(
    id: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createDatabasePropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createDatabaseProperty(
    id: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createDatabasePropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling createDatabaseProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createDatabaseProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/databases/${encodeURIComponent(
            String(id),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createDatabasePropertyOpts?.config,
            headers: {
              ...headers,
              ...createDatabasePropertyOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Create content property for folder
   * Creates a new content property for a folder.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the folder.
   * @param id The ID of the folder to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createFolderPropertyOpts.config] Override http request option.
   */
  public createFolderProperty(
    id: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createFolderPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createFolderProperty(
    id: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createFolderPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling createFolderProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createFolderProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/folders/${encodeURIComponent(
            String(id),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createFolderPropertyOpts?.config,
            headers: {
              ...headers,
              ...createFolderPropertyOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Create content property for page
   * Creates a new content property for a page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the page.
   * @param pageId The ID of the page to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createPagePropertyOpts.config] Override http request option.
   */
  public createPageProperty(
    pageId: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createPagePropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createPageProperty(
    pageId: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createPagePropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (pageId === null || pageId === undefined) {
      throw new Error(
        "Required parameter pageId was null or undefined when calling createPageProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createPageProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/pages/${encodeURIComponent(
            String(pageId),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createPagePropertyOpts?.config,
            headers: { ...headers, ...createPagePropertyOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Create content property for Smart Link in the content tree
   * Creates a new content property for a Smart Link in the content tree.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the Smart Link in the content tree.
   * @param id The ID of the Smart Link in the content tree to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createSmartLinkPropertyOpts.config] Override http request option.
   */
  public createSmartLinkProperty(
    id: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createSmartLinkPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createSmartLinkProperty(
    id: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createSmartLinkPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling createSmartLinkProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createSmartLinkProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/embeds/${encodeURIComponent(
            String(id),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createSmartLinkPropertyOpts?.config,
            headers: {
              ...headers,
              ...createSmartLinkPropertyOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Create content property for whiteboard
   * Creates a new content property for a whiteboard.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the whiteboard.
   * @param id The ID of the whiteboard to create a property for.
   * @param contentPropertyCreateRequest The content property to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createWhiteboardPropertyOpts.config] Override http request option.
   */
  public createWhiteboardProperty(
    id: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createWhiteboardPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public createWhiteboardProperty(
    id: number,
    contentPropertyCreateRequest: ContentPropertyCreateRequest,
    createWhiteboardPropertyOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling createWhiteboardProperty.",
      );
    }

    if (
      contentPropertyCreateRequest === null ||
      contentPropertyCreateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyCreateRequest was null or undefined when calling createWhiteboardProperty.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<ContentProperty>(
          `${this.basePath}/whiteboards/${encodeURIComponent(
            String(id),
          )}/properties`,
          contentPropertyCreateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...createWhiteboardPropertyOpts?.config,
            headers: {
              ...headers,
              ...createWhiteboardPropertyOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for attachment by id
   * Deletes a content property for an attachment by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to attachment the page.
   * @param attachmentId The ID of the attachment the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteAttachmentPropertyByIdOpts.config] Override http request option.
   */
  public deleteAttachmentPropertyById(
    attachmentId: string,
    propertyId: number,
    deleteAttachmentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteAttachmentPropertyById(
    attachmentId: string,
    propertyId: number,
    deleteAttachmentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (attachmentId === null || attachmentId === undefined) {
      throw new Error(
        "Required parameter attachmentId was null or undefined when calling deleteAttachmentPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deleteAttachmentPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/attachments/${encodeURIComponent(
            String(attachmentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteAttachmentPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deleteAttachmentPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for blogpost by id
   * Deletes a content property for a blogpost by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the blog post.
   * @param blogpostId The ID of the blog post the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteBlogpostPropertyByIdOpts.config] Override http request option.
   */
  public deleteBlogpostPropertyById(
    blogpostId: number,
    propertyId: number,
    deleteBlogpostPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteBlogpostPropertyById(
    blogpostId: number,
    propertyId: number,
    deleteBlogpostPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (blogpostId === null || blogpostId === undefined) {
      throw new Error(
        "Required parameter blogpostId was null or undefined when calling deleteBlogpostPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deleteBlogpostPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/blogposts/${encodeURIComponent(
            String(blogpostId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteBlogpostPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deleteBlogpostPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for comment by id
   * Deletes a content property for a comment by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the comment.
   * @param commentId The ID of the comment the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteCommentPropertyByIdOpts.config] Override http request option.
   */
  public deleteCommentPropertyById(
    commentId: number,
    propertyId: number,
    deleteCommentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteCommentPropertyById(
    commentId: number,
    propertyId: number,
    deleteCommentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling deleteCommentPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deleteCommentPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/comments/${encodeURIComponent(
            String(commentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteCommentPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deleteCommentPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for custom content by id
   * Deletes a content property for a piece of custom content by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the custom content.
   * @param customContentId The ID of the custom content the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteCustomContentPropertyByIdOpts.config] Override http request option.
   */
  public deleteCustomContentPropertyById(
    customContentId: number,
    propertyId: number,
    deleteCustomContentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteCustomContentPropertyById(
    customContentId: number,
    propertyId: number,
    deleteCustomContentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (customContentId === null || customContentId === undefined) {
      throw new Error(
        "Required parameter customContentId was null or undefined when calling deleteCustomContentPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deleteCustomContentPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/custom-content/${encodeURIComponent(
            String(customContentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteCustomContentPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deleteCustomContentPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for database by id
   * Deletes a content property for a database by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the database.
   * @param databaseId The ID of the database the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteDatabasePropertyByIdOpts.config] Override http request option.
   */
  public deleteDatabasePropertyById(
    databaseId: number,
    propertyId: number,
    deleteDatabasePropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteDatabasePropertyById(
    databaseId: number,
    propertyId: number,
    deleteDatabasePropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (databaseId === null || databaseId === undefined) {
      throw new Error(
        "Required parameter databaseId was null or undefined when calling deleteDatabasePropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deleteDatabasePropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/databases/${encodeURIComponent(
            String(databaseId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteDatabasePropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deleteDatabasePropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for folder by id
   * Deletes a content property for a folder by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the folder.
   * @param folderId The ID of the folder the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteFolderPropertyByIdOpts.config] Override http request option.
   */
  public deleteFolderPropertyById(
    folderId: number,
    propertyId: number,
    deleteFolderPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteFolderPropertyById(
    folderId: number,
    propertyId: number,
    deleteFolderPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (folderId === null || folderId === undefined) {
      throw new Error(
        "Required parameter folderId was null or undefined when calling deleteFolderPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deleteFolderPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/folders/${encodeURIComponent(
            String(folderId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteFolderPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deleteFolderPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for page by id
   * Deletes a content property for a page by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the page.
   * @param pageId The ID of the page the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deletePagePropertyByIdOpts.config] Override http request option.
   */
  public deletePagePropertyById(
    pageId: number,
    propertyId: number,
    deletePagePropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deletePagePropertyById(
    pageId: number,
    propertyId: number,
    deletePagePropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (pageId === null || pageId === undefined) {
      throw new Error(
        "Required parameter pageId was null or undefined when calling deletePagePropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deletePagePropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/pages/${encodeURIComponent(
            String(pageId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deletePagePropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deletePagePropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for Smart Link in the content tree by id
   * Deletes a content property for a Smart Link in the content tree by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the Smart Link in the content tree.
   * @param embedId The ID of the Smart Link in the content tree the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteSmartLinkPropertyByIdOpts.config] Override http request option.
   */
  public deleteSmartLinkPropertyById(
    embedId: number,
    propertyId: number,
    deleteSmartLinkPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteSmartLinkPropertyById(
    embedId: number,
    propertyId: number,
    deleteSmartLinkPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (embedId === null || embedId === undefined) {
      throw new Error(
        "Required parameter embedId was null or undefined when calling deleteSmartLinkPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deleteSmartLinkPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/embeds/${encodeURIComponent(
            String(embedId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteSmartLinkPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deleteSmartLinkPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete content property for whiteboard by id
   * Deletes a content property for a whiteboard by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the whiteboard.
   * @param whiteboardId The ID of the whiteboard the property belongs to.
   * @param propertyId The ID of the property to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteWhiteboardPropertyByIdOpts.config] Override http request option.
   */
  public deleteWhiteboardPropertyById(
    whiteboardId: number,
    propertyId: number,
    deleteWhiteboardPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteWhiteboardPropertyById(
    whiteboardId: number,
    propertyId: number,
    deleteWhiteboardPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (whiteboardId === null || whiteboardId === undefined) {
      throw new Error(
        "Required parameter whiteboardId was null or undefined when calling deleteWhiteboardPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling deleteWhiteboardPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/whiteboards/${encodeURIComponent(
            String(whiteboardId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteWhiteboardPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...deleteWhiteboardPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for attachment
   * Retrieves all Content Properties tied to a specified attachment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the attachment.
   * @param attachmentId The ID of the attachment for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getAttachmentContentPropertiesOpts.config] Override http request option.
   */
  public getAttachmentContentProperties(
    attachmentId: string,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getAttachmentContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getAttachmentContentProperties(
    attachmentId: string,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getAttachmentContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (attachmentId === null || attachmentId === undefined) {
      throw new Error(
        "Required parameter attachmentId was null or undefined when calling getAttachmentContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/attachments/${encodeURIComponent(
            String(attachmentId),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getAttachmentContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getAttachmentContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for attachment by id
   * Retrieves a specific Content Property by ID that is attached to a specified attachment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the attachment.
   * @param attachmentId The ID of the attachment for which content properties should be returned.
   * @param propertyId The ID of the content property to be returned
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getAttachmentContentPropertiesByIdOpts.config] Override http request option.
   */
  public getAttachmentContentPropertiesById(
    attachmentId: string,
    propertyId: number,
    getAttachmentContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getAttachmentContentPropertiesById(
    attachmentId: string,
    propertyId: number,
    getAttachmentContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (attachmentId === null || attachmentId === undefined) {
      throw new Error(
        "Required parameter attachmentId was null or undefined when calling getAttachmentContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getAttachmentContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/attachments/${encodeURIComponent(
            String(attachmentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getAttachmentContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getAttachmentContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for blog post
   * Retrieves all Content Properties tied to a specified blog post.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the blog post.
   * @param blogpostId The ID of the blog post for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getBlogpostContentPropertiesOpts.config] Override http request option.
   */
  public getBlogpostContentProperties(
    blogpostId: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getBlogpostContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getBlogpostContentProperties(
    blogpostId: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getBlogpostContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (blogpostId === null || blogpostId === undefined) {
      throw new Error(
        "Required parameter blogpostId was null or undefined when calling getBlogpostContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/blogposts/${encodeURIComponent(
            String(blogpostId),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getBlogpostContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getBlogpostContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for blog post by id
   * Retrieves a specific Content Property by ID that is attached to a specified blog post.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the blog post.
   * @param blogpostId The ID of the blog post for which content properties should be returned.
   * @param propertyId The ID of the property being requested
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getBlogpostContentPropertiesByIdOpts.config] Override http request option.
   */
  public getBlogpostContentPropertiesById(
    blogpostId: number,
    propertyId: number,
    getBlogpostContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getBlogpostContentPropertiesById(
    blogpostId: number,
    propertyId: number,
    getBlogpostContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (blogpostId === null || blogpostId === undefined) {
      throw new Error(
        "Required parameter blogpostId was null or undefined when calling getBlogpostContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getBlogpostContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/blogposts/${encodeURIComponent(
            String(blogpostId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getBlogpostContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getBlogpostContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for comment
   * Retrieves Content Properties attached to a specified comment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the comment.
   * @param commentId The ID of the comment for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getCommentContentPropertiesOpts.config] Override http request option.
   */
  public getCommentContentProperties(
    commentId: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getCommentContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getCommentContentProperties(
    commentId: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getCommentContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling getCommentContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/comments/${encodeURIComponent(
            String(commentId),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getCommentContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getCommentContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for comment by id
   * Retrieves a specific Content Property by ID that is attached to a specified comment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the comment.
   * @param commentId The ID of the comment for which content properties should be returned.
   * @param propertyId The ID of the content property being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getCommentContentPropertiesByIdOpts.config] Override http request option.
   */
  public getCommentContentPropertiesById(
    commentId: number,
    propertyId: number,
    getCommentContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getCommentContentPropertiesById(
    commentId: number,
    propertyId: number,
    getCommentContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling getCommentContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getCommentContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/comments/${encodeURIComponent(
            String(commentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getCommentContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getCommentContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for custom content
   * Retrieves Content Properties tied to a specified custom content.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content.
   * @param customContentId The ID of the custom content for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getCustomContentContentPropertiesOpts.config] Override http request option.
   */
  public getCustomContentContentProperties(
    customContentId: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getCustomContentContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getCustomContentContentProperties(
    customContentId: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getCustomContentContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (customContentId === null || customContentId === undefined) {
      throw new Error(
        "Required parameter customContentId was null or undefined when calling getCustomContentContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/custom-content/${encodeURIComponent(
            String(customContentId),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getCustomContentContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getCustomContentContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for custom content by id
   * Retrieves a specific Content Property by ID that is attached to a specified custom content.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page.
   * @param customContentId The ID of the custom content for which content properties should be returned.
   * @param propertyId The ID of the content property being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getCustomContentContentPropertiesByIdOpts.config] Override http request option.
   */
  public getCustomContentContentPropertiesById(
    customContentId: number,
    propertyId: number,
    getCustomContentContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getCustomContentContentPropertiesById(
    customContentId: number,
    propertyId: number,
    getCustomContentContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (customContentId === null || customContentId === undefined) {
      throw new Error(
        "Required parameter customContentId was null or undefined when calling getCustomContentContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getCustomContentContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/custom-content/${encodeURIComponent(
            String(customContentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getCustomContentContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getCustomContentContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for database
   * Retrieves Content Properties tied to a specified database.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the database.
   * @param id The ID of the database for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getDatabaseContentPropertiesOpts.config] Override http request option.
   */
  public getDatabaseContentProperties(
    id: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getDatabaseContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getDatabaseContentProperties(
    id: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getDatabaseContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getDatabaseContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/databases/${encodeURIComponent(
            String(id),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getDatabaseContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getDatabaseContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for database by id
   * Retrieves a specific Content Property by ID that is attached to a specified database.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the database.
   * @param databaseId The ID of the database for which content properties should be returned.
   * @param propertyId The ID of the content property being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getDatabaseContentPropertiesByIdOpts.config] Override http request option.
   */
  public getDatabaseContentPropertiesById(
    databaseId: number,
    propertyId: number,
    getDatabaseContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getDatabaseContentPropertiesById(
    databaseId: number,
    propertyId: number,
    getDatabaseContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (databaseId === null || databaseId === undefined) {
      throw new Error(
        "Required parameter databaseId was null or undefined when calling getDatabaseContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getDatabaseContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/databases/${encodeURIComponent(
            String(databaseId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getDatabaseContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getDatabaseContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for folder
   * Retrieves Content Properties tied to a specified folder.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the folder.
   * @param id The ID of the folder for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getFolderContentPropertiesOpts.config] Override http request option.
   */
  public getFolderContentProperties(
    id: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getFolderContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getFolderContentProperties(
    id: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getFolderContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getFolderContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/folders/${encodeURIComponent(
            String(id),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getFolderContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getFolderContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for folder by id
   * Retrieves a specific Content Property by ID that is attached to a specified folder.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the folder.
   * @param folderId The ID of the folder for which content properties should be returned.
   * @param propertyId The ID of the content property being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getFolderContentPropertiesByIdOpts.config] Override http request option.
   */
  public getFolderContentPropertiesById(
    folderId: number,
    propertyId: number,
    getFolderContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getFolderContentPropertiesById(
    folderId: number,
    propertyId: number,
    getFolderContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (folderId === null || folderId === undefined) {
      throw new Error(
        "Required parameter folderId was null or undefined when calling getFolderContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getFolderContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/folders/${encodeURIComponent(
            String(folderId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getFolderContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getFolderContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for page
   * Retrieves Content Properties tied to a specified page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page.
   * @param pageId The ID of the page for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getPageContentPropertiesOpts.config] Override http request option.
   */
  public getPageContentProperties(
    pageId: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getPageContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getPageContentProperties(
    pageId: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getPageContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (pageId === null || pageId === undefined) {
      throw new Error(
        "Required parameter pageId was null or undefined when calling getPageContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/pages/${encodeURIComponent(
            String(pageId),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getPageContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getPageContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for page by id
   * Retrieves a specific Content Property by ID that is attached to a specified page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page.
   * @param pageId The ID of the page for which content properties should be returned.
   * @param propertyId The ID of the content property being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getPageContentPropertiesByIdOpts.config] Override http request option.
   */
  public getPageContentPropertiesById(
    pageId: number,
    propertyId: number,
    getPageContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getPageContentPropertiesById(
    pageId: number,
    propertyId: number,
    getPageContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (pageId === null || pageId === undefined) {
      throw new Error(
        "Required parameter pageId was null or undefined when calling getPageContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getPageContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/pages/${encodeURIComponent(
            String(pageId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getPageContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getPageContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for Smart Link in the content tree
   * Retrieves Content Properties tied to a specified Smart Link in the content tree.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the Smart Link in the content tree.
   * @param id The ID of the Smart Link in the content tree for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of Smart Links per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getSmartLinkContentPropertiesOpts.config] Override http request option.
   */
  public getSmartLinkContentProperties(
    id: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getSmartLinkContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getSmartLinkContentProperties(
    id: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getSmartLinkContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getSmartLinkContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/embeds/${encodeURIComponent(
            String(id),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getSmartLinkContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getSmartLinkContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for Smart Link in the content tree by id
   * Retrieves a specific Content Property by ID that is attached to a specified Smart Link in the content tree.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the Smart Link in the content tree.
   * @param embedId The ID of the Smart Link in the content tree for which content properties should be returned.
   * @param propertyId The ID of the content property being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getSmartLinkContentPropertiesByIdOpts.config] Override http request option.
   */
  public getSmartLinkContentPropertiesById(
    embedId: number,
    propertyId: number,
    getSmartLinkContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getSmartLinkContentPropertiesById(
    embedId: number,
    propertyId: number,
    getSmartLinkContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (embedId === null || embedId === undefined) {
      throw new Error(
        "Required parameter embedId was null or undefined when calling getSmartLinkContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getSmartLinkContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/embeds/${encodeURIComponent(
            String(embedId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getSmartLinkContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getSmartLinkContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content properties for whiteboard
   * Retrieves Content Properties tied to a specified whiteboard.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the whiteboard.
   * @param id The ID of the whiteboard for which content properties should be returned.
   * @param key Filters the response to return a specific content property with matching key (case sensitive).
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of attachments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getWhiteboardContentPropertiesOpts.config] Override http request option.
   */
  public getWhiteboardContentProperties(
    id: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getWhiteboardContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultContentProperty>>;
  public getWhiteboardContentProperties(
    id: number,
    key?: string,
    sort?: ContentPropertySortOrder,
    cursor?: string,
    limit?: number,
    getWhiteboardContentPropertiesOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getWhiteboardContentProperties.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (key !== undefined && key !== null) {
      queryParameters.append("key", <any>key);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultContentProperty>(
          `${this.basePath}/whiteboards/${encodeURIComponent(
            String(id),
          )}/properties`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getWhiteboardContentPropertiesOpts?.config,
            headers: {
              ...headers,
              ...getWhiteboardContentPropertiesOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get content property for whiteboard by id
   * Retrieves a specific Content Property by ID that is attached to a specified whiteboard.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the whiteboard.
   * @param whiteboardId The ID of the whiteboard for which content properties should be returned.
   * @param propertyId The ID of the content property being requested.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getWhiteboardContentPropertiesByIdOpts.config] Override http request option.
   */
  public getWhiteboardContentPropertiesById(
    whiteboardId: number,
    propertyId: number,
    getWhiteboardContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public getWhiteboardContentPropertiesById(
    whiteboardId: number,
    propertyId: number,
    getWhiteboardContentPropertiesByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (whiteboardId === null || whiteboardId === undefined) {
      throw new Error(
        "Required parameter whiteboardId was null or undefined when calling getWhiteboardContentPropertiesById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling getWhiteboardContentPropertiesById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<ContentProperty>(
          `${this.basePath}/whiteboards/${encodeURIComponent(
            String(whiteboardId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...getWhiteboardContentPropertiesByIdOpts?.config,
            headers: {
              ...headers,
              ...getWhiteboardContentPropertiesByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for attachment by id
   * Update a content property for attachment by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the attachment.
   * @param attachmentId The ID of the attachment the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateAttachmentPropertyByIdOpts.config] Override http request option.
   */
  public updateAttachmentPropertyById(
    attachmentId: string,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateAttachmentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updateAttachmentPropertyById(
    attachmentId: string,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateAttachmentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (attachmentId === null || attachmentId === undefined) {
      throw new Error(
        "Required parameter attachmentId was null or undefined when calling updateAttachmentPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updateAttachmentPropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updateAttachmentPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/attachments/${encodeURIComponent(
            String(attachmentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateAttachmentPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updateAttachmentPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for blog post by id
   * Update a content property for blog post by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the blog post.
   * @param blogpostId The ID of the blog post the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateBlogpostPropertyByIdOpts.config] Override http request option.
   */
  public updateBlogpostPropertyById(
    blogpostId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateBlogpostPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updateBlogpostPropertyById(
    blogpostId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateBlogpostPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (blogpostId === null || blogpostId === undefined) {
      throw new Error(
        "Required parameter blogpostId was null or undefined when calling updateBlogpostPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updateBlogpostPropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updateBlogpostPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/blogposts/${encodeURIComponent(
            String(blogpostId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateBlogpostPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updateBlogpostPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for comment by id
   * Update a content property for a comment by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the comment.
   * @param commentId The ID of the comment the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateCommentPropertyByIdOpts.config] Override http request option.
   */
  public updateCommentPropertyById(
    commentId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateCommentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updateCommentPropertyById(
    commentId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateCommentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling updateCommentPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updateCommentPropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updateCommentPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/comments/${encodeURIComponent(
            String(commentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateCommentPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updateCommentPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for custom content by id
   * Update a content property for a piece of custom content by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the custom content.
   * @param customContentId The ID of the custom content the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateCustomContentPropertyByIdOpts.config] Override http request option.
   */
  public updateCustomContentPropertyById(
    customContentId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateCustomContentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updateCustomContentPropertyById(
    customContentId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateCustomContentPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (customContentId === null || customContentId === undefined) {
      throw new Error(
        "Required parameter customContentId was null or undefined when calling updateCustomContentPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updateCustomContentPropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updateCustomContentPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/custom-content/${encodeURIComponent(
            String(customContentId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateCustomContentPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updateCustomContentPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for database by id
   * Update a content property for a database by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the database.
   * @param databaseId The ID of the database the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateDatabasePropertyByIdOpts.config] Override http request option.
   */
  public updateDatabasePropertyById(
    databaseId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateDatabasePropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updateDatabasePropertyById(
    databaseId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateDatabasePropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (databaseId === null || databaseId === undefined) {
      throw new Error(
        "Required parameter databaseId was null or undefined when calling updateDatabasePropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updateDatabasePropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updateDatabasePropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/databases/${encodeURIComponent(
            String(databaseId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateDatabasePropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updateDatabasePropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for folder by id
   * Update a content property for a folder by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the folder.
   * @param folderId The ID of the folder the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateFolderPropertyByIdOpts.config] Override http request option.
   */
  public updateFolderPropertyById(
    folderId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateFolderPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updateFolderPropertyById(
    folderId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateFolderPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (folderId === null || folderId === undefined) {
      throw new Error(
        "Required parameter folderId was null or undefined when calling updateFolderPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updateFolderPropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updateFolderPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/folders/${encodeURIComponent(
            String(folderId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateFolderPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updateFolderPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for page by id
   * Update a content property for a page by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the page.
   * @param pageId The ID of the page the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updatePagePropertyByIdOpts.config] Override http request option.
   */
  public updatePagePropertyById(
    pageId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updatePagePropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updatePagePropertyById(
    pageId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updatePagePropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (pageId === null || pageId === undefined) {
      throw new Error(
        "Required parameter pageId was null or undefined when calling updatePagePropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updatePagePropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updatePagePropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/pages/${encodeURIComponent(
            String(pageId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updatePagePropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updatePagePropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for Smart Link in the content tree by id
   * Update a content property for a Smart Link in the content tree by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the Smart Link in the content tree.
   * @param embedId The ID of the Smart Link in the content tree the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateSmartLinkPropertyByIdOpts.config] Override http request option.
   */
  public updateSmartLinkPropertyById(
    embedId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateSmartLinkPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updateSmartLinkPropertyById(
    embedId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateSmartLinkPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (embedId === null || embedId === undefined) {
      throw new Error(
        "Required parameter embedId was null or undefined when calling updateSmartLinkPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updateSmartLinkPropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updateSmartLinkPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/embeds/${encodeURIComponent(
            String(embedId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateSmartLinkPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updateSmartLinkPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update content property for whiteboard by id
   * Update a content property for a whiteboard by its id.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the whiteboard.
   * @param whiteboardId The ID of the whiteboard the property belongs to.
   * @param propertyId The ID of the property to be updated.
   * @param contentPropertyUpdateRequest The content property to be updated.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateWhiteboardPropertyByIdOpts.config] Override http request option.
   */
  public updateWhiteboardPropertyById(
    whiteboardId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateWhiteboardPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<ContentProperty>>;
  public updateWhiteboardPropertyById(
    whiteboardId: number,
    propertyId: number,
    contentPropertyUpdateRequest: ContentPropertyUpdateRequest,
    updateWhiteboardPropertyByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (whiteboardId === null || whiteboardId === undefined) {
      throw new Error(
        "Required parameter whiteboardId was null or undefined when calling updateWhiteboardPropertyById.",
      );
    }

    if (propertyId === null || propertyId === undefined) {
      throw new Error(
        "Required parameter propertyId was null or undefined when calling updateWhiteboardPropertyById.",
      );
    }

    if (
      contentPropertyUpdateRequest === null ||
      contentPropertyUpdateRequest === undefined
    ) {
      throw new Error(
        "Required parameter contentPropertyUpdateRequest was null or undefined when calling updateWhiteboardPropertyById.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<ContentProperty>(
          `${this.basePath}/whiteboards/${encodeURIComponent(
            String(whiteboardId),
          )}/properties/${encodeURIComponent(String(propertyId))}`,
          contentPropertyUpdateRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateWhiteboardPropertyByIdOpts?.config,
            headers: {
              ...headers,
              ...updateWhiteboardPropertyByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
}
