/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { ClassificationLevel } from '../model/classificationLevel';
import { PostPageClassificationLevelRequest } from '../model/postPageClassificationLevelRequest';
import { PostWhiteboardClassificationLevelRequest } from '../model/postWhiteboardClassificationLevelRequest';
import { PutPageClassificationLevelRequest } from '../model/putPageClassificationLevelRequest';
import { PutSpaceDefaultClassificationLevelRequest } from '../model/putSpaceDefaultClassificationLevelRequest';
import { PutWhiteboardClassificationLevelRequest } from '../model/putWhiteboardClassificationLevelRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class ClassificationLevelService {

    protected basePath = 'https://no-default/wiki/api/v2';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Delete space default classification level
     * Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/)  for a specific space.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and \&#39;Admin\&#39; permission for the space.
     * @param id The ID of the space for which default classification level should be deleted.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteSpaceDefaultClassificationLevelOpts.config] Override http request option.
     */
    public deleteSpaceDefaultClassificationLevel(id: number, deleteSpaceDefaultClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public deleteSpaceDefaultClassificationLevel(id: number, deleteSpaceDefaultClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteSpaceDefaultClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/spaces/${encodeURIComponent(String(id))}/classification-level/default`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...deleteSpaceDefaultClassificationLevelOpts?.config,
                        headers: {...headers, ...deleteSpaceDefaultClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get blog post classification level
     * Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific blog post.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the blog post. \&#39;Permission to edit the blog post is required if trying to view classification level for a draft.
     * @param id The ID of the blog post for which classification level should be returned.
     * @param status Status of blog post from which classification level will fetched.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getBlogPostClassificationLevelOpts.config] Override http request option.
     */
    public getBlogPostClassificationLevel(id: number, status?: 'current' | 'draft' | 'archived', getBlogPostClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ClassificationLevel>>;
    public getBlogPostClassificationLevel(id: number, status?: 'current' | 'draft' | 'archived', getBlogPostClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBlogPostClassificationLevel.');
        }

        let queryParameters = new URLSearchParams();
        if (status !== undefined && status !== null) {
            queryParameters.append('status', <any>status);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ClassificationLevel>(`${this.basePath}/blogposts/${encodeURIComponent(String(id))}/classification-level`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getBlogPostClassificationLevelOpts?.config,
                        headers: {...headers, ...getBlogPostClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get list of classification levels
     * Returns a list of [classification levels](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level)  available.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getClassificationLevelsOpts.config] Override http request option.
     */
    public getClassificationLevels(getClassificationLevelsOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Array<ClassificationLevel>>>;
    public getClassificationLevels(getClassificationLevelsOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Array<ClassificationLevel>>(`${this.basePath}/classification-levels`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getClassificationLevelsOpts?.config,
                        headers: {...headers, ...getClassificationLevelsOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get database classification level
     * Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific database.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the database.
     * @param id The ID of the database for which classification level should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getDatabaseClassificationLevelOpts.config] Override http request option.
     */
    public getDatabaseClassificationLevel(id: number, getDatabaseClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ClassificationLevel>>;
    public getDatabaseClassificationLevel(id: number, getDatabaseClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDatabaseClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ClassificationLevel>(`${this.basePath}/databases/${encodeURIComponent(String(id))}/classification-level`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getDatabaseClassificationLevelOpts?.config,
                        headers: {...headers, ...getDatabaseClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get page classification level
     * Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the page. \&#39;Permission to edit the page is required if trying to view classification level for a draft.
     * @param id The ID of the page for which classification level should be returned.
     * @param status Status of page from which classification level will fetched.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getPageClassificationLevelOpts.config] Override http request option.
     */
    public getPageClassificationLevel(id: number, status?: 'current' | 'draft' | 'archived', getPageClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ClassificationLevel>>;
    public getPageClassificationLevel(id: number, status?: 'current' | 'draft' | 'archived', getPageClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPageClassificationLevel.');
        }

        let queryParameters = new URLSearchParams();
        if (status !== undefined && status !== null) {
            queryParameters.append('status', <any>status);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ClassificationLevel>(`${this.basePath}/pages/${encodeURIComponent(String(id))}/classification-level`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getPageClassificationLevelOpts?.config,
                        headers: {...headers, ...getPageClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get space default classification level
     * Returns the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/)  for a specific space.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the space.
     * @param id The ID of the space for which default classification level should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getSpaceDefaultClassificationLevelOpts.config] Override http request option.
     */
    public getSpaceDefaultClassificationLevel(id: number, getSpaceDefaultClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ClassificationLevel>>;
    public getSpaceDefaultClassificationLevel(id: number, getSpaceDefaultClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSpaceDefaultClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ClassificationLevel>(`${this.basePath}/spaces/${encodeURIComponent(String(id))}/classification-level/default`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getSpaceDefaultClassificationLevelOpts?.config,
                        headers: {...headers, ...getSpaceDefaultClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get whiteboard classification level
     * Returns the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific whiteboard.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the whiteboard.
     * @param id The ID of the whiteboard for which classification level should be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getWhiteboardClassificationLevelOpts.config] Override http request option.
     */
    public getWhiteboardClassificationLevel(id: number, getWhiteboardClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ClassificationLevel>>;
    public getWhiteboardClassificationLevel(id: number, getWhiteboardClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getWhiteboardClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<ClassificationLevel>(`${this.basePath}/whiteboards/${encodeURIComponent(String(id))}/classification-level`,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...getWhiteboardClassificationLevelOpts?.config,
                        headers: {...headers, ...getWhiteboardClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Reset blog post classification level
     * Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific blog post for the space   [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the blog post.
     * @param id The ID of the blog post for which classification level should be updated.
     * @param postPageClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [postBlogPostClassificationLevelOpts.config] Override http request option.
     */
    public postBlogPostClassificationLevel(id: number, postPageClassificationLevelRequest: PostPageClassificationLevelRequest, postBlogPostClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public postBlogPostClassificationLevel(id: number, postPageClassificationLevelRequest: PostPageClassificationLevelRequest, postBlogPostClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postBlogPostClassificationLevel.');
        }

        if (postPageClassificationLevelRequest === null || postPageClassificationLevelRequest === undefined) {
            throw new Error('Required parameter postPageClassificationLevelRequest was null or undefined when calling postBlogPostClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/blogposts/${encodeURIComponent(String(id))}/classification-level/reset`,
                    postPageClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...postBlogPostClassificationLevelOpts?.config,
                        headers: {...headers, ...postBlogPostClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Reset database classification level
     * Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific database for the space  [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the database.
     * @param id The ID of the database for which classification level should be updated.
     * @param postWhiteboardClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [postDatabaseClassificationLevelOpts.config] Override http request option.
     */
    public postDatabaseClassificationLevel(id: number, postWhiteboardClassificationLevelRequest: PostWhiteboardClassificationLevelRequest, postDatabaseClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public postDatabaseClassificationLevel(id: number, postWhiteboardClassificationLevelRequest: PostWhiteboardClassificationLevelRequest, postDatabaseClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postDatabaseClassificationLevel.');
        }

        if (postWhiteboardClassificationLevelRequest === null || postWhiteboardClassificationLevelRequest === undefined) {
            throw new Error('Required parameter postWhiteboardClassificationLevelRequest was null or undefined when calling postDatabaseClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/databases/${encodeURIComponent(String(id))}/classification-level/reset`,
                    postWhiteboardClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...postDatabaseClassificationLevelOpts?.config,
                        headers: {...headers, ...postDatabaseClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Reset page classification level
     * Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific page for the space  [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the page.
     * @param id The ID of the page for which classification level should be updated.
     * @param postPageClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [postPageClassificationLevelOpts.config] Override http request option.
     */
    public postPageClassificationLevel(id: number, postPageClassificationLevelRequest: PostPageClassificationLevelRequest, postPageClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public postPageClassificationLevel(id: number, postPageClassificationLevelRequest: PostPageClassificationLevelRequest, postPageClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postPageClassificationLevel.');
        }

        if (postPageClassificationLevelRequest === null || postPageClassificationLevelRequest === undefined) {
            throw new Error('Required parameter postPageClassificationLevelRequest was null or undefined when calling postPageClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/pages/${encodeURIComponent(String(id))}/classification-level/reset`,
                    postPageClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...postPageClassificationLevelOpts?.config,
                        headers: {...headers, ...postPageClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Reset whiteboard classification level
     * Resets the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific whiteboard for the space  [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to view the whiteboard.
     * @param id The ID of the whiteboard for which classification level should be updated.
     * @param postWhiteboardClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [postWhiteboardClassificationLevelOpts.config] Override http request option.
     */
    public postWhiteboardClassificationLevel(id: number, postWhiteboardClassificationLevelRequest: PostWhiteboardClassificationLevelRequest, postWhiteboardClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public postWhiteboardClassificationLevel(id: number, postWhiteboardClassificationLevelRequest: PostWhiteboardClassificationLevelRequest, postWhiteboardClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postWhiteboardClassificationLevel.');
        }

        if (postWhiteboardClassificationLevelRequest === null || postWhiteboardClassificationLevelRequest === undefined) {
            throw new Error('Required parameter postWhiteboardClassificationLevelRequest was null or undefined when calling postWhiteboardClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<any>(`${this.basePath}/whiteboards/${encodeURIComponent(String(id))}/classification-level/reset`,
                    postWhiteboardClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...postWhiteboardClassificationLevelOpts?.config,
                        headers: {...headers, ...postWhiteboardClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update blog post classification level
     * Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific blog post.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to edit the blog post.
     * @param id The ID of the blog post for which classification level should be updated.
     * @param putPageClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [putBlogPostClassificationLevelOpts.config] Override http request option.
     */
    public putBlogPostClassificationLevel(id: number, putPageClassificationLevelRequest: PutPageClassificationLevelRequest, putBlogPostClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public putBlogPostClassificationLevel(id: number, putPageClassificationLevelRequest: PutPageClassificationLevelRequest, putBlogPostClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling putBlogPostClassificationLevel.');
        }

        if (putPageClassificationLevelRequest === null || putPageClassificationLevelRequest === undefined) {
            throw new Error('Required parameter putPageClassificationLevelRequest was null or undefined when calling putBlogPostClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<any>(`${this.basePath}/blogposts/${encodeURIComponent(String(id))}/classification-level`,
                    putPageClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...putBlogPostClassificationLevelOpts?.config,
                        headers: {...headers, ...putBlogPostClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update database classification level
     * Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific database.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to edit the database.
     * @param id The ID of the database for which classification level should be updated.
     * @param putWhiteboardClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [putDatabaseClassificationLevelOpts.config] Override http request option.
     */
    public putDatabaseClassificationLevel(id: number, putWhiteboardClassificationLevelRequest: PutWhiteboardClassificationLevelRequest, putDatabaseClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public putDatabaseClassificationLevel(id: number, putWhiteboardClassificationLevelRequest: PutWhiteboardClassificationLevelRequest, putDatabaseClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling putDatabaseClassificationLevel.');
        }

        if (putWhiteboardClassificationLevelRequest === null || putWhiteboardClassificationLevelRequest === undefined) {
            throw new Error('Required parameter putWhiteboardClassificationLevelRequest was null or undefined when calling putDatabaseClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<any>(`${this.basePath}/databases/${encodeURIComponent(String(id))}/classification-level`,
                    putWhiteboardClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...putDatabaseClassificationLevelOpts?.config,
                        headers: {...headers, ...putDatabaseClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update page classification level
     * Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to edit the page.
     * @param id The ID of the page for which classification level should be updated.
     * @param putPageClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [putPageClassificationLevelOpts.config] Override http request option.
     */
    public putPageClassificationLevel(id: number, putPageClassificationLevelRequest: PutPageClassificationLevelRequest, putPageClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public putPageClassificationLevel(id: number, putPageClassificationLevelRequest: PutPageClassificationLevelRequest, putPageClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling putPageClassificationLevel.');
        }

        if (putPageClassificationLevelRequest === null || putPageClassificationLevelRequest === undefined) {
            throw new Error('Required parameter putPageClassificationLevelRequest was null or undefined when calling putPageClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<any>(`${this.basePath}/pages/${encodeURIComponent(String(id))}/classification-level`,
                    putPageClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...putPageClassificationLevelOpts?.config,
                        headers: {...headers, ...putPageClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update space default classification level
     * Update the [default classification level](https://support.atlassian.com/security-and-access-policies/docs/what-is-a-default-classification-level/)  for a specific space.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and \&#39;Admin\&#39; permission for the space.
     * @param id The ID of the space for which default classification level should be updated.
     * @param putSpaceDefaultClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [putSpaceDefaultClassificationLevelOpts.config] Override http request option.
     */
    public putSpaceDefaultClassificationLevel(id: number, putSpaceDefaultClassificationLevelRequest: PutSpaceDefaultClassificationLevelRequest, putSpaceDefaultClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public putSpaceDefaultClassificationLevel(id: number, putSpaceDefaultClassificationLevelRequest: PutSpaceDefaultClassificationLevelRequest, putSpaceDefaultClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling putSpaceDefaultClassificationLevel.');
        }

        if (putSpaceDefaultClassificationLevelRequest === null || putSpaceDefaultClassificationLevelRequest === undefined) {
            throw new Error('Required parameter putSpaceDefaultClassificationLevelRequest was null or undefined when calling putSpaceDefaultClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<any>(`${this.basePath}/spaces/${encodeURIComponent(String(id))}/classification-level/default`,
                    putSpaceDefaultClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...putSpaceDefaultClassificationLevelOpts?.config,
                        headers: {...headers, ...putSpaceDefaultClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update whiteboard classification level
     * Updates the [classification level](https://developer.atlassian.com/cloud/admin/dlp/rest/intro/#Classification%20level) for a specific whiteboard.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \&#39;Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and permission to edit the whiteboard.
     * @param id The ID of the whiteboard for which classification level should be updated.
     * @param putWhiteboardClassificationLevelRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [putWhiteboardClassificationLevelOpts.config] Override http request option.
     */
    public putWhiteboardClassificationLevel(id: number, putWhiteboardClassificationLevelRequest: PutWhiteboardClassificationLevelRequest, putWhiteboardClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public putWhiteboardClassificationLevel(id: number, putWhiteboardClassificationLevelRequest: PutWhiteboardClassificationLevelRequest, putWhiteboardClassificationLevelOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling putWhiteboardClassificationLevel.');
        }

        if (putWhiteboardClassificationLevelRequest === null || putWhiteboardClassificationLevelRequest === undefined) {
            throw new Error('Required parameter putWhiteboardClassificationLevelRequest was null or undefined when calling putWhiteboardClassificationLevel.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<any>(`${this.basePath}/whiteboards/${encodeURIComponent(String(id))}/classification-level`,
                    putWhiteboardClassificationLevelRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...putWhiteboardClassificationLevelOpts?.config,
                        headers: {...headers, ...putWhiteboardClassificationLevelOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
