/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { CreatePage200Response } from '../model/createPage200Response';
import { CreatePageRequest } from '../model/createPageRequest';
import { MultiEntityResultPage } from '../model/multiEntityResultPage';
import { PageSortOrder } from '../model/pageSortOrder';
import { PrimaryBodyRepresentation } from '../model/primaryBodyRepresentation';
import { PrimaryBodyRepresentationSingle } from '../model/primaryBodyRepresentationSingle';
import { UpdatePageRequest } from '../model/updatePageRequest';
import { UpdatePageTitleRequest } from '../model/updatePageTitleRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class PageService {

    protected basePath = 'https://no-default/wiki/api/v2';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Create page
     * Creates a page in the space.  Pages are created as published by default unless specified as a draft in the status field. If creating a published page, the title must be specified.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the corresponding space. Permission to create a page in the space.
     * @param createPageRequest 
     * @param embedded Tag the content as embedded and content will be created in NCS.
     * @param _private The page will be private. Only the user who creates this page will have permission to view and edit one.
     * @param rootLevel The page will be created at the root level of the space (outside the space homepage tree). If true, then a  value may not be supplied for the &#x60;parentId&#x60; body parameter.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createPageOpts.config] Override http request option.
     */
    public createPage(createPageRequest: CreatePageRequest, embedded?: boolean, _private?: boolean, rootLevel?: boolean, createPageOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<CreatePage200Response>>;
    public createPage(createPageRequest: CreatePageRequest, embedded?: boolean, _private?: boolean, rootLevel?: boolean, createPageOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (createPageRequest === null || createPageRequest === undefined) {
            throw new Error('Required parameter createPageRequest was null or undefined when calling createPage.');
        }

        let queryParameters = new URLSearchParams();
        if (embedded !== undefined && embedded !== null) {
            queryParameters.append('embedded', <any>embedded);
        }
        if (_private !== undefined && _private !== null) {
            queryParameters.append('private', <any>_private);
        }
        if (rootLevel !== undefined && rootLevel !== null) {
            queryParameters.append('root-level', <any>rootLevel);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<CreatePage200Response>(`${this.basePath}/pages`,
                    createPageRequest,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...createPageOpts?.config,
                        headers: {...headers, ...createPageOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Delete page
     * Delete a page by id.  By default this will delete pages that are non-drafts. To delete a page that is a draft, the endpoint must be called on a  draft with the following param &#x60;draft&#x3D;true&#x60;. Discarded drafts are not sent to the trash and are permanently deleted.  Deleting a page moves the page to the trash, where it can be restored later. To permanently delete a page (or \&quot;purge\&quot; it), the endpoint must be called on a **trashed** page with the following param &#x60;purge&#x3D;true&#x60;.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to delete pages in the space. Permission to administer the space (if attempting to purge).
     * @param id The ID of the page to be deleted.
     * @param purge If attempting to purge the page.
     * @param draft If attempting to delete a page that is a draft.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deletePageOpts.config] Override http request option.
     */
    public deletePage(id: number, purge?: boolean, draft?: boolean, deletePageOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public deletePage(id: number, purge?: boolean, draft?: boolean, deletePageOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePage.');
        }

        let queryParameters = new URLSearchParams();
        if (purge !== undefined && purge !== null) {
            queryParameters.append('purge', <any>purge);
        }
        if (draft !== undefined && draft !== null) {
            queryParameters.append('draft', <any>draft);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/pages/${encodeURIComponent(String(id))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...deletePageOpts?.config,
                        headers: {...headers, ...deletePageOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get pages for label
     * Returns the pages of specified label. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * @param id The ID of the label for which pages should be returned.
     * @param spaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getLabelPagesOpts.config] Override http request option.
     */
    public getLabelPages(id: number, spaceId?: Array<number>, bodyFormat?: PrimaryBodyRepresentation, sort?: PageSortOrder, cursor?: string, limit?: number, getLabelPagesOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultPage>>;
    public getLabelPages(id: number, spaceId?: Array<number>, bodyFormat?: PrimaryBodyRepresentation, sort?: PageSortOrder, cursor?: string, limit?: number, getLabelPagesOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLabelPages.');
        }

        let queryParameters = new URLSearchParams();
        if (spaceId) {
            spaceId.forEach((element) => {
                queryParameters.append('space-id', <any>element);
            })
        }
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultPage>(`${this.basePath}/labels/${encodeURIComponent(String(id))}/pages`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getLabelPagesOpts?.config,
                        headers: {...headers, ...getLabelPagesOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get page by id
     * Returns a specific page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space.
     * @param id The ID of the page to be returned. If you don\&#39;t know the page ID, use Get pages and filter the results.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
     * @param getDraft Retrieve the draft version of this page.
     * @param status Filter the page being retrieved by its status.
     * @param version Allows you to retrieve a previously published version. Specify the previous version\&#39;s number to retrieve its details.
     * @param includeLabels Includes labels associated with this page in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeProperties Includes content properties associated with this page in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeOperations Includes operations associated with this page in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeLikes Includes likes associated with this page in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeVersions Includes versions associated with this page in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeVersion Includes the current version associated with this page in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
     * @param includeFavoritedByCurrentUserStatus Includes whether this page has been favorited by the current user.
     * @param includeWebresources Includes web resources that can be used to render page content on a client.
     * @param includeCollaborators Includes collaborators on the page.
     * @param includeDirectChildren Includes direct children of the page, as defined in the &#x60;ChildrenResponse&#x60; object.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getPageByIdOpts.config] Override http request option.
     */
    public getPageById(id: number, bodyFormat?: PrimaryBodyRepresentationSingle, getDraft?: boolean, status?: Array<'current' | 'archived' | 'trashed' | 'deleted' | 'historical' | 'draft'>, version?: number, includeLabels?: boolean, includeProperties?: boolean, includeOperations?: boolean, includeLikes?: boolean, includeVersions?: boolean, includeVersion?: boolean, includeFavoritedByCurrentUserStatus?: boolean, includeWebresources?: boolean, includeCollaborators?: boolean, includeDirectChildren?: boolean, getPageByIdOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<CreatePage200Response>>;
    public getPageById(id: number, bodyFormat?: PrimaryBodyRepresentationSingle, getDraft?: boolean, status?: Array<'current' | 'archived' | 'trashed' | 'deleted' | 'historical' | 'draft'>, version?: number, includeLabels?: boolean, includeProperties?: boolean, includeOperations?: boolean, includeLikes?: boolean, includeVersions?: boolean, includeVersion?: boolean, includeFavoritedByCurrentUserStatus?: boolean, includeWebresources?: boolean, includeCollaborators?: boolean, includeDirectChildren?: boolean, getPageByIdOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPageById.');
        }

        let queryParameters = new URLSearchParams();
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }
        if (getDraft !== undefined && getDraft !== null) {
            queryParameters.append('get-draft', <any>getDraft);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters.append('status', <any>element);
            })
        }
        if (version !== undefined && version !== null) {
            queryParameters.append('version', <any>version);
        }
        if (includeLabels !== undefined && includeLabels !== null) {
            queryParameters.append('include-labels', <any>includeLabels);
        }
        if (includeProperties !== undefined && includeProperties !== null) {
            queryParameters.append('include-properties', <any>includeProperties);
        }
        if (includeOperations !== undefined && includeOperations !== null) {
            queryParameters.append('include-operations', <any>includeOperations);
        }
        if (includeLikes !== undefined && includeLikes !== null) {
            queryParameters.append('include-likes', <any>includeLikes);
        }
        if (includeVersions !== undefined && includeVersions !== null) {
            queryParameters.append('include-versions', <any>includeVersions);
        }
        if (includeVersion !== undefined && includeVersion !== null) {
            queryParameters.append('include-version', <any>includeVersion);
        }
        if (includeFavoritedByCurrentUserStatus !== undefined && includeFavoritedByCurrentUserStatus !== null) {
            queryParameters.append('include-favorited-by-current-user-status', <any>includeFavoritedByCurrentUserStatus);
        }
        if (includeWebresources !== undefined && includeWebresources !== null) {
            queryParameters.append('include-webresources', <any>includeWebresources);
        }
        if (includeCollaborators !== undefined && includeCollaborators !== null) {
            queryParameters.append('include-collaborators', <any>includeCollaborators);
        }
        if (includeDirectChildren !== undefined && includeDirectChildren !== null) {
            queryParameters.append('include-direct-children', <any>includeDirectChildren);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<CreatePage200Response>(`${this.basePath}/pages/${encodeURIComponent(String(id))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getPageByIdOpts?.config,
                        headers: {...headers, ...getPageByIdOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get pages
     * Returns all pages. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission). Only pages that the user has permission to view will be returned.
     * @param id Filter the results based on page ids. Multiple page ids can be specified as a comma-separated list.
     * @param spaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
     * @param sort Used to sort the result by a particular field.
     * @param status Filter the results to pages based on their status. By default, &#x60;current&#x60; and &#x60;archived&#x60; are used.
     * @param title Filter the results to pages based on their title.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
     * @param subtype Filter the results to pages based on their subtype.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getPagesOpts.config] Override http request option.
     */
    public getPages(id?: Array<number>, spaceId?: Array<number>, sort?: PageSortOrder, status?: Array<'current' | 'archived' | 'deleted' | 'trashed'>, title?: string, bodyFormat?: PrimaryBodyRepresentation, subtype?: 'live' | 'page', cursor?: string, limit?: number, getPagesOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultPage>>;
    public getPages(id?: Array<number>, spaceId?: Array<number>, sort?: PageSortOrder, status?: Array<'current' | 'archived' | 'deleted' | 'trashed'>, title?: string, bodyFormat?: PrimaryBodyRepresentation, subtype?: 'live' | 'page', cursor?: string, limit?: number, getPagesOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (id) {
            id.forEach((element) => {
                queryParameters.append('id', <any>element);
            })
        }
        if (spaceId) {
            spaceId.forEach((element) => {
                queryParameters.append('space-id', <any>element);
            })
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters.append('status', <any>element);
            })
        }
        if (title !== undefined && title !== null) {
            queryParameters.append('title', <any>title);
        }
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }
        if (subtype !== undefined && subtype !== null) {
            queryParameters.append('subtype', <any>subtype);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultPage>(`${this.basePath}/pages`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getPagesOpts?.config,
                        headers: {...headers, ...getPagesOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get pages in space
     * Returns all pages in a space. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission) and \&#39;View\&#39; permission for the space. Only pages that the user has permission to view will be returned.
     * @param id The ID of the space for which pages should be returned.
     * @param depth Filter the results to pages at the root level of the space or to all pages in the space.
     * @param sort Used to sort the result by a particular field.
     * @param status Filter the results to pages based on their status. By default, &#x60;current&#x60; and &#x60;archived&#x60; are used.
     * @param title Filter the results to pages based on their title.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getPagesInSpaceOpts.config] Override http request option.
     */
    public getPagesInSpace(id: number, depth?: 'all' | 'root', sort?: PageSortOrder, status?: Array<'current' | 'archived' | 'deleted' | 'trashed'>, title?: string, bodyFormat?: PrimaryBodyRepresentation, cursor?: string, limit?: number, getPagesInSpaceOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultPage>>;
    public getPagesInSpace(id: number, depth?: 'all' | 'root', sort?: PageSortOrder, status?: Array<'current' | 'archived' | 'deleted' | 'trashed'>, title?: string, bodyFormat?: PrimaryBodyRepresentation, cursor?: string, limit?: number, getPagesInSpaceOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPagesInSpace.');
        }

        let queryParameters = new URLSearchParams();
        if (depth !== undefined && depth !== null) {
            queryParameters.append('depth', <any>depth);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (status) {
            status.forEach((element) => {
                queryParameters.append('status', <any>element);
            })
        }
        if (title !== undefined && title !== null) {
            queryParameters.append('title', <any>title);
        }
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultPage>(`${this.basePath}/spaces/${encodeURIComponent(String(id))}/pages`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getPagesInSpaceOpts?.config,
                        headers: {...headers, ...getPagesInSpaceOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update page
     * Update a page by id.  When the \&quot;current\&quot; version is updated, the provided body content is considered as the latest version. This latest body content will be attempted to be merged into the draft version through a content reconciliation algorithm. If two versions are significantly diverged,  the latest provided content may entirely override what was previously in the draft.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to update pages in the space.
     * @param id The ID of the page to be updated. If you don\&#39;t know the page ID, use Get Pages and filter the results.
     * @param updatePageRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [updatePageOpts.config] Override http request option.
     */
    public updatePage(id: number, updatePageRequest: UpdatePageRequest, updatePageOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<CreatePage200Response>>;
    public updatePage(id: number, updatePageRequest: UpdatePageRequest, updatePageOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePage.');
        }

        if (updatePageRequest === null || updatePageRequest === undefined) {
            throw new Error('Required parameter updatePageRequest was null or undefined when calling updatePage.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<CreatePage200Response>(`${this.basePath}/pages/${encodeURIComponent(String(id))}`,
                    updatePageRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...updatePageOpts?.config,
                        headers: {...headers, ...updatePageOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update page title
     * Updates the title of a specified page.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the page and its corresponding space. Permission to update pages in the space.
     * @param id The ID of the page to be updated. If you don\&#39;t know the page ID, use Get Pages and filter the results
     * @param updatePageTitleRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [updatePageTitleOpts.config] Override http request option.
     */
    public updatePageTitle(id: number, updatePageTitleRequest: UpdatePageTitleRequest, updatePageTitleOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<CreatePage200Response>>;
    public updatePageTitle(id: number, updatePageTitleRequest: UpdatePageTitleRequest, updatePageTitleOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePageTitle.');
        }

        if (updatePageTitleRequest === null || updatePageTitleRequest === undefined) {
            throw new Error('Required parameter updatePageTitleRequest was null or undefined when calling updatePageTitle.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<CreatePage200Response>(`${this.basePath}/pages/${encodeURIComponent(String(id))}/title`,
                    updatePageTitleRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...updatePageTitleOpts?.config,
                        headers: {...headers, ...updatePageTitleOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
