/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { ContentIdToContentTypeResponse } from '../model/contentIdToContentTypeResponse';
import { ConvertContentIdsToContentTypesRequest } from '../model/convertContentIdsToContentTypesRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class ContentService {

    protected basePath = 'https://no-default/wiki/api/v2';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Convert content ids to content types
     * Converts a list of content ids into their associated content types. This is useful for users migrating from v1 to v2 who may have stored just content ids without their associated type. This will return types as they should be used in v2. Notably, this will return &#x60;inline-comment&#x60; for inline comments and &#x60;footer-comment&#x60; for footer comments, which is distinct from them both being represented by &#x60;comment&#x60; in v1.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the requested content. Any content that the user does not have permission to view or does not exist will map to &#x60;null&#x60; in the response.
     * @param convertContentIdsToContentTypesRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [convertContentIdsToContentTypesOpts.config] Override http request option.
     */
    public convertContentIdsToContentTypes(convertContentIdsToContentTypesRequest: ConvertContentIdsToContentTypesRequest, convertContentIdsToContentTypesOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<ContentIdToContentTypeResponse>>;
    public convertContentIdsToContentTypes(convertContentIdsToContentTypesRequest: ConvertContentIdsToContentTypesRequest, convertContentIdsToContentTypesOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (convertContentIdsToContentTypesRequest === null || convertContentIdsToContentTypesRequest === undefined) {
            throw new Error('Required parameter convertContentIdsToContentTypesRequest was null or undefined when calling convertContentIdsToContentTypes.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<ContentIdToContentTypeResponse>(`${this.basePath}/content/convert-ids-to-types`,
                    convertContentIdsToContentTypesRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...convertContentIdsToContentTypesOpts?.config,
                        headers: {...headers, ...convertContentIdsToContentTypesOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
