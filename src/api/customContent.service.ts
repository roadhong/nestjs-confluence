/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { CreateCustomContent201Response } from '../model/createCustomContent201Response';
import { CreateCustomContentRequest } from '../model/createCustomContentRequest';
import { CustomContentBodyRepresentation } from '../model/customContentBodyRepresentation';
import { CustomContentBodyRepresentationSingle } from '../model/customContentBodyRepresentationSingle';
import { CustomContentSortOrder } from '../model/customContentSortOrder';
import { MultiEntityResultCustomContent } from '../model/multiEntityResultCustomContent';
import { UpdateCustomContentRequest } from '../model/updateCustomContentRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class CustomContentService {

    protected basePath = 'https://no-default/wiki/api/v2';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Create custom content
     * Creates a new custom content in the given space, page, blogpost or other custom content.  Only one of &#x60;spaceId&#x60;, &#x60;pageId&#x60;, &#x60;blogPostId&#x60;, or &#x60;customContentId&#x60; is required in the request body. **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create custom content in the space.
     * @param createCustomContentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [createCustomContentOpts.config] Override http request option.
     */
    public createCustomContent(createCustomContentRequest: CreateCustomContentRequest, createCustomContentOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<CreateCustomContent201Response>>;
    public createCustomContent(createCustomContentRequest: CreateCustomContentRequest, createCustomContentOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (createCustomContentRequest === null || createCustomContentRequest === undefined) {
            throw new Error('Required parameter createCustomContentRequest was null or undefined when calling createCustomContent.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.post<CreateCustomContent201Response>(`${this.basePath}/custom-content`,
                    createCustomContentRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...createCustomContentOpts?.config,
                        headers: {...headers, ...createCustomContentOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Delete custom content
     * Delete a custom content by id.  Deleting a custom content will either move it to the trash or permanently delete it (purge it), depending on the apiSupport. To permanently delete a **trashed** custom content, the endpoint must be called with the following param &#x60;purge&#x3D;true&#x60;.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to delete custom content in the space. Permission to administer the space (if attempting to purge).
     * @param id The ID of the custom content to be deleted.
     * @param purge If attempting to purge the custom content.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [deleteCustomContentOpts.config] Override http request option.
     */
    public deleteCustomContent(id: number, purge?: boolean, deleteCustomContentOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<any>>;
    public deleteCustomContent(id: number, purge?: boolean, deleteCustomContentOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCustomContent.');
        }

        let queryParameters = new URLSearchParams();
        if (purge !== undefined && purge !== null) {
            queryParameters.append('purge', <any>purge);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.delete<any>(`${this.basePath}/custom-content/${encodeURIComponent(String(id))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...deleteCustomContentOpts?.config,
                        headers: {...headers, ...deleteCustomContentOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get custom content by id
     * Returns a specific piece of custom content.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
     * @param id The ID of the custom content to be returned. If you don\&#39;t know the custom content ID, use Get Custom Content by Type and filter the results.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
     * @param version Allows you to retrieve a previously published version. Specify the previous version\&#39;s number to retrieve its details.
     * @param includeLabels Includes labels associated with this custom content in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeProperties Includes content properties associated with this custom content in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeOperations Includes operations associated with this custom content in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeVersions Includes versions associated with this custom content in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
     * @param includeVersion Includes the current version associated with this custom content in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
     * @param includeCollaborators Includes collaborators on the custom content.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getCustomContentByIdOpts.config] Override http request option.
     */
    public getCustomContentById(id: number, bodyFormat?: CustomContentBodyRepresentationSingle, version?: number, includeLabels?: boolean, includeProperties?: boolean, includeOperations?: boolean, includeVersions?: boolean, includeVersion?: boolean, includeCollaborators?: boolean, getCustomContentByIdOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<CreateCustomContent201Response>>;
    public getCustomContentById(id: number, bodyFormat?: CustomContentBodyRepresentationSingle, version?: number, includeLabels?: boolean, includeProperties?: boolean, includeOperations?: boolean, includeVersions?: boolean, includeVersion?: boolean, includeCollaborators?: boolean, getCustomContentByIdOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomContentById.');
        }

        let queryParameters = new URLSearchParams();
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }
        if (version !== undefined && version !== null) {
            queryParameters.append('version', <any>version);
        }
        if (includeLabels !== undefined && includeLabels !== null) {
            queryParameters.append('include-labels', <any>includeLabels);
        }
        if (includeProperties !== undefined && includeProperties !== null) {
            queryParameters.append('include-properties', <any>includeProperties);
        }
        if (includeOperations !== undefined && includeOperations !== null) {
            queryParameters.append('include-operations', <any>includeOperations);
        }
        if (includeVersions !== undefined && includeVersions !== null) {
            queryParameters.append('include-versions', <any>includeVersions);
        }
        if (includeVersion !== undefined && includeVersion !== null) {
            queryParameters.append('include-version', <any>includeVersion);
        }
        if (includeCollaborators !== undefined && includeCollaborators !== null) {
            queryParameters.append('include-collaborators', <any>includeCollaborators);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<CreateCustomContent201Response>(`${this.basePath}/custom-content/${encodeURIComponent(String(id))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getCustomContentByIdOpts?.config,
                        headers: {...headers, ...getCustomContentByIdOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get custom content by type
     * Returns all custom content for a given type. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content, the container of the custom content, and the corresponding space (if different from the container).
     * @param type The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
     * @param id Filter the results based on custom content ids. Multiple custom content ids can be specified as a comma-separated list.
     * @param spaceId Filter the results based on space ids. Multiple space ids can be specified as a comma-separated list.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getCustomContentByTypeOpts.config] Override http request option.
     */
    public getCustomContentByType(type: string, id?: Array<number>, spaceId?: Array<number>, sort?: CustomContentSortOrder, cursor?: string, limit?: number, bodyFormat?: CustomContentBodyRepresentation, getCustomContentByTypeOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultCustomContent>>;
    public getCustomContentByType(type: string, id?: Array<number>, spaceId?: Array<number>, sort?: CustomContentSortOrder, cursor?: string, limit?: number, bodyFormat?: CustomContentBodyRepresentation, getCustomContentByTypeOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getCustomContentByType.');
        }

        let queryParameters = new URLSearchParams();
        if (type !== undefined && type !== null) {
            queryParameters.append('type', <any>type);
        }
        if (id) {
            id.forEach((element) => {
                queryParameters.append('id', <any>element);
            })
        }
        if (spaceId) {
            spaceId.forEach((element) => {
                queryParameters.append('space-id', <any>element);
            })
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultCustomContent>(`${this.basePath}/custom-content`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getCustomContentByTypeOpts?.config,
                        headers: {...headers, ...getCustomContentByTypeOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get custom content by type in blog post
     * Returns all custom content for a given type within a given blogpost. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content, the container of the custom content (blog post), and the corresponding space.
     * @param id The ID of the blog post for which custom content should be returned.
     * @param type The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getCustomContentByTypeInBlogPostOpts.config] Override http request option.
     */
    public getCustomContentByTypeInBlogPost(id: number, type: string, sort?: CustomContentSortOrder, cursor?: string, limit?: number, bodyFormat?: CustomContentBodyRepresentation, getCustomContentByTypeInBlogPostOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultCustomContent>>;
    public getCustomContentByTypeInBlogPost(id: number, type: string, sort?: CustomContentSortOrder, cursor?: string, limit?: number, bodyFormat?: CustomContentBodyRepresentation, getCustomContentByTypeInBlogPostOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomContentByTypeInBlogPost.');
        }

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getCustomContentByTypeInBlogPost.');
        }

        let queryParameters = new URLSearchParams();
        if (type !== undefined && type !== null) {
            queryParameters.append('type', <any>type);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultCustomContent>(`${this.basePath}/blogposts/${encodeURIComponent(String(id))}/custom-content`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getCustomContentByTypeInBlogPostOpts?.config,
                        headers: {...headers, ...getCustomContentByTypeInBlogPostOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get custom content by type in page
     * Returns all custom content for a given type within a given page. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content, the container of the custom content (page), and the corresponding space.
     * @param id The ID of the page for which custom content should be returned.
     * @param type The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
     * @param sort Used to sort the result by a particular field.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getCustomContentByTypeInPageOpts.config] Override http request option.
     */
    public getCustomContentByTypeInPage(id: number, type: string, sort?: CustomContentSortOrder, cursor?: string, limit?: number, bodyFormat?: CustomContentBodyRepresentation, getCustomContentByTypeInPageOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultCustomContent>>;
    public getCustomContentByTypeInPage(id: number, type: string, sort?: CustomContentSortOrder, cursor?: string, limit?: number, bodyFormat?: CustomContentBodyRepresentation, getCustomContentByTypeInPageOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomContentByTypeInPage.');
        }

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getCustomContentByTypeInPage.');
        }

        let queryParameters = new URLSearchParams();
        if (type !== undefined && type !== null) {
            queryParameters.append('type', <any>type);
        }
        if (sort !== undefined && sort !== null) {
            queryParameters.append('sort', <any>sort);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultCustomContent>(`${this.basePath}/pages/${encodeURIComponent(String(id))}/custom-content`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getCustomContentByTypeInPageOpts?.config,
                        headers: {...headers, ...getCustomContentByTypeInPageOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get custom content by type in space
     * Returns all custom content for a given type within a given space. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content and the corresponding space.
     * @param id The ID of the space for which custom content should be returned.
     * @param type The type of custom content being requested. See: https://developer.atlassian.com/cloud/confluence/custom-content/ for additional details on custom content.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of pages per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.  Note: If the custom content body type is &#x60;storage&#x60;, the &#x60;storage&#x60; and &#x60;atlas_doc_format&#x60; body formats are able to be returned. If the custom content body type is &#x60;raw&#x60;, only the &#x60;raw&#x60; body format is able to be returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getCustomContentByTypeInSpaceOpts.config] Override http request option.
     */
    public getCustomContentByTypeInSpace(id: number, type: string, cursor?: string, limit?: number, bodyFormat?: CustomContentBodyRepresentation, getCustomContentByTypeInSpaceOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultCustomContent>>;
    public getCustomContentByTypeInSpace(id: number, type: string, cursor?: string, limit?: number, bodyFormat?: CustomContentBodyRepresentation, getCustomContentByTypeInSpaceOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomContentByTypeInSpace.');
        }

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getCustomContentByTypeInSpace.');
        }

        let queryParameters = new URLSearchParams();
        if (type !== undefined && type !== null) {
            queryParameters.append('type', <any>type);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultCustomContent>(`${this.basePath}/spaces/${encodeURIComponent(String(id))}/custom-content`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getCustomContentByTypeInSpaceOpts?.config,
                        headers: {...headers, ...getCustomContentByTypeInSpaceOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update custom content
     * Update a custom content by id. At most one of &#x60;spaceId&#x60;, &#x60;pageId&#x60;, &#x60;blogPostId&#x60;, or &#x60;customContentId&#x60; is allowed in the request body. Note that if &#x60;spaceId&#x60; is specified, it must be the same as the &#x60;spaceId&#x60; used for creating the custom content as moving custom content to a different space is not supported.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to update custom content in the space.
     * @param id The ID of the custom content to be updated. If you don\&#39;t know the custom content ID, use Get Custom Content by Type and filter the results.
     * @param updateCustomContentRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [updateCustomContentOpts.config] Override http request option.
     */
    public updateCustomContent(id: number, updateCustomContentRequest: UpdateCustomContentRequest, updateCustomContentOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<CreateCustomContent201Response>>;
    public updateCustomContent(id: number, updateCustomContentRequest: UpdateCustomContentRequest, updateCustomContentOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateCustomContent.');
        }

        if (updateCustomContentRequest === null || updateCustomContentRequest === undefined) {
            throw new Error('Required parameter updateCustomContentRequest was null or undefined when calling updateCustomContent.');
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<CreateCustomContent201Response>(`${this.basePath}/custom-content/${encodeURIComponent(String(id))}`,
                    updateCustomContentRequest,
                    {
                        withCredentials: this.configuration.withCredentials,
                        ...updateCustomContentOpts?.config,
                        headers: {...headers, ...updateCustomContentOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
