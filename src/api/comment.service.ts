/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { HttpService } from "@nestjs/axios";
import { Injectable, Optional } from "@nestjs/common";
import type { AxiosRequestConfig, AxiosResponse } from "axios";
import { Observable, from, of, switchMap } from "rxjs";
import { Configuration } from "../configuration";
import { CommentSortOrder } from "../model/commentSortOrder";
import { CreateFooterComment201Response } from "../model/createFooterComment201Response";
import { CreateFooterCommentModel } from "../model/createFooterCommentModel";
import { CreateInlineComment201Response } from "../model/createInlineComment201Response";
import { CreateInlineCommentModel } from "../model/createInlineCommentModel";
import { FooterCommentModel } from "../model/footerCommentModel";
import { MultiEntityResultAttachmentCommentModel } from "../model/multiEntityResultAttachmentCommentModel";
import { MultiEntityResultBlogPostCommentModel } from "../model/multiEntityResultBlogPostCommentModel";
import { MultiEntityResultBlogPostInlineCommentModel } from "../model/multiEntityResultBlogPostInlineCommentModel";
import { MultiEntityResultChildrenCommentModel } from "../model/multiEntityResultChildrenCommentModel";
import { MultiEntityResultCustomContentCommentModel } from "../model/multiEntityResultCustomContentCommentModel";
import { MultiEntityResultFooterCommentModel } from "../model/multiEntityResultFooterCommentModel";
import { MultiEntityResultInlineCommentChildrenModel } from "../model/multiEntityResultInlineCommentChildrenModel";
import { MultiEntityResultInlineCommentModel } from "../model/multiEntityResultInlineCommentModel";
import { MultiEntityResultPageCommentModel } from "../model/multiEntityResultPageCommentModel";
import { MultiEntityResultPageInlineCommentModel } from "../model/multiEntityResultPageInlineCommentModel";
import { PrimaryBodyRepresentation } from "../model/primaryBodyRepresentation";
import { PrimaryBodyRepresentationSingle } from "../model/primaryBodyRepresentationSingle";
import { UpdateFooterCommentRequest } from "../model/updateFooterCommentRequest";
import { UpdateInlineCommentModel } from "../model/updateInlineCommentModel";

@Injectable()
export class CommentService {
  protected basePath = "https://no-default/wiki/api/v2";
  public defaultHeaders: Record<string, string> = {};
  public configuration = new Configuration();
  protected httpClient: HttpService;

  constructor(
    httpClient: HttpService,
    @Optional() configuration: Configuration,
  ) {
    this.configuration = configuration || this.configuration;
    this.basePath = configuration?.basePath || this.basePath;
    this.httpClient = configuration?.httpClient || httpClient;
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = "multipart/form-data";
    return consumes.includes(form);
  }

  /**
   * Create footer comment
   * Create a footer comment.  The footer comment can be made against several locations:  - at the top level (specifying pageId or blogPostId in the request body) - as a reply (specifying parentCommentId in the request body) - against an attachment (note: this is different than the comments added via the attachment properties page on the UI, which are referred to as version comments) - against a custom content  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
   * @param createFooterCommentModel The footer comment to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createFooterCommentOpts.config] Override http request option.
   */
  public createFooterComment(
    createFooterCommentModel: CreateFooterCommentModel,
    createFooterCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<CreateFooterComment201Response>>;
  public createFooterComment(
    createFooterCommentModel: CreateFooterCommentModel,
    createFooterCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (
      createFooterCommentModel === null ||
      createFooterCommentModel === undefined
    ) {
      throw new Error(
        "Required parameter createFooterCommentModel was null or undefined when calling createFooterComment.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<CreateFooterComment201Response>(
          `${this.basePath}/footer-comments`,
          createFooterCommentModel,
          {
            withCredentials: this.configuration.withCredentials,
            ...createFooterCommentOpts?.config,
            headers: {
              ...headers,
              ...createFooterCommentOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Create inline comment
   * Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body) or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the request body is used to select the text the inline comment should be tied to. This is what determines the text  highlighting when viewing a page in Confluence.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
   * @param createInlineCommentModel The inline comment to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [createInlineCommentOpts.config] Override http request option.
   */
  public createInlineComment(
    createInlineCommentModel: CreateInlineCommentModel,
    createInlineCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<CreateInlineComment201Response>>;
  public createInlineComment(
    createInlineCommentModel: CreateInlineCommentModel,
    createInlineCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (
      createInlineCommentModel === null ||
      createInlineCommentModel === undefined
    ) {
      throw new Error(
        "Required parameter createInlineCommentModel was null or undefined when calling createInlineComment.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.post<CreateInlineComment201Response>(
          `${this.basePath}/inline-comments`,
          createInlineCommentModel,
          {
            withCredentials: this.configuration.withCredentials,
            ...createInlineCommentOpts?.config,
            headers: {
              ...headers,
              ...createInlineCommentOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete footer comment
   * Deletes a footer comment. This is a permanent deletion and cannot be reverted.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
   * @param commentId The ID of the comment to be retrieved.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteFooterCommentOpts.config] Override http request option.
   */
  public deleteFooterComment(
    commentId: number,
    deleteFooterCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteFooterComment(
    commentId: number,
    deleteFooterCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling deleteFooterComment.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/footer-comments/${encodeURIComponent(
            String(commentId),
          )}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteFooterCommentOpts?.config,
            headers: {
              ...headers,
              ...deleteFooterCommentOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Delete inline comment
   * Deletes an inline comment. This is a permanent deletion and cannot be reverted.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
   * @param commentId The ID of the comment to be deleted.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [deleteInlineCommentOpts.config] Override http request option.
   */
  public deleteInlineComment(
    commentId: number,
    deleteInlineCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<any>>;
  public deleteInlineComment(
    commentId: number,
    deleteInlineCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling deleteInlineComment.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = [];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.delete<any>(
          `${this.basePath}/inline-comments/${encodeURIComponent(
            String(commentId),
          )}`,
          {
            withCredentials: this.configuration.withCredentials,
            ...deleteInlineCommentOpts?.config,
            headers: {
              ...headers,
              ...deleteInlineCommentOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get attachment comments
   * Returns the comments of the specific attachment. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the attachment and its corresponding containers.
   * @param id The ID of the attachment for which comments should be returned.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param sort Used to sort the result by a particular field.
   * @param version Version number of the attachment to retrieve comments for. If no version provided, retrieves comments for the latest version.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getAttachmentCommentsOpts.config] Override http request option.
   */
  public getAttachmentComments(
    id: string,
    bodyFormat?: PrimaryBodyRepresentation,
    cursor?: string,
    limit?: number,
    sort?: CommentSortOrder,
    version?: number,
    getAttachmentCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultAttachmentCommentModel>>;
  public getAttachmentComments(
    id: string,
    bodyFormat?: PrimaryBodyRepresentation,
    cursor?: string,
    limit?: number,
    sort?: CommentSortOrder,
    version?: number,
    getAttachmentCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getAttachmentComments.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (version !== undefined && version !== null) {
      queryParameters.append("version", <any>version);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultAttachmentCommentModel>(
          `${this.basePath}/attachments/${encodeURIComponent(
            String(id),
          )}/footer-comments`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getAttachmentCommentsOpts?.config,
            headers: {
              ...headers,
              ...getAttachmentCommentsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get footer comments for blog post
   * Returns the root footer comments of specific blog post. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the blog post and its corresponding space.
   * @param id The ID of the blog post for which footer comments should be returned.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param status Filter the footer comment being retrieved by its status.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getBlogPostFooterCommentsOpts.config] Override http request option.
   */
  public getBlogPostFooterComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    status?: Array<"current" | "deleted" | "trashed" | "historical" | "draft">,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getBlogPostFooterCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultBlogPostCommentModel>>;
  public getBlogPostFooterComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    status?: Array<"current" | "deleted" | "trashed" | "historical" | "draft">,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getBlogPostFooterCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getBlogPostFooterComments.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (status) {
      status.forEach((element) => {
        queryParameters.append("status", <any>element);
      });
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultBlogPostCommentModel>(
          `${this.basePath}/blogposts/${encodeURIComponent(
            String(id),
          )}/footer-comments`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getBlogPostFooterCommentsOpts?.config,
            headers: {
              ...headers,
              ...getBlogPostFooterCommentsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get inline comments for blog post
   * Returns the root inline comments of specific blog post. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the blog post and its corresponding space.
   * @param id The ID of the blog post for which inline comments should be returned.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param status Filter the inline comment being retrieved by its status.
   * @param resolutionStatus Filter the inline comment being retrieved by its resolution status.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of inline comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getBlogPostInlineCommentsOpts.config] Override http request option.
   */
  public getBlogPostInlineComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    status?: Array<"current" | "deleted" | "trashed" | "historical" | "draft">,
    resolutionStatus?: Array<"resolved" | "open" | "dangling" | "reopened">,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getBlogPostInlineCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultBlogPostInlineCommentModel>>;
  public getBlogPostInlineComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    status?: Array<"current" | "deleted" | "trashed" | "historical" | "draft">,
    resolutionStatus?: Array<"resolved" | "open" | "dangling" | "reopened">,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getBlogPostInlineCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getBlogPostInlineComments.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (status) {
      status.forEach((element) => {
        queryParameters.append("status", <any>element);
      });
    }
    if (resolutionStatus) {
      resolutionStatus.forEach((element) => {
        queryParameters.append("resolution-status", <any>element);
      });
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultBlogPostInlineCommentModel>(
          `${this.basePath}/blogposts/${encodeURIComponent(
            String(id),
          )}/inline-comments`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getBlogPostInlineCommentsOpts?.config,
            headers: {
              ...headers,
              ...getBlogPostInlineCommentsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get custom content comments
   * Returns the comments of the specific custom content. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content and its corresponding containers.
   * @param id The ID of the custom content for which comments should be returned.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param sort Used to sort the result by a particular field.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getCustomContentCommentsOpts.config] Override http request option.
   */
  public getCustomContentComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    cursor?: string,
    limit?: number,
    sort?: CommentSortOrder,
    getCustomContentCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultCustomContentCommentModel>>;
  public getCustomContentComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    cursor?: string,
    limit?: number,
    sort?: CommentSortOrder,
    getCustomContentCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getCustomContentComments.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultCustomContentCommentModel>(
          `${this.basePath}/custom-content/${encodeURIComponent(
            String(id),
          )}/footer-comments`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getCustomContentCommentsOpts?.config,
            headers: {
              ...headers,
              ...getCustomContentCommentsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get footer comment by id
   * Retrieves a footer comment by id  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the container and its corresponding space.
   * @param commentId The ID of the comment to be retrieved.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param version Allows you to retrieve a previously published version. Specify the previous version\&#39;s number to retrieve its details.
   * @param includeProperties Includes content properties associated with this footer comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeOperations Includes operations associated with this footer comment in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeLikes Includes likes associated with this footer comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeVersions Includes versions associated with this footer comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeVersion Includes the current version associated with this footer comment in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getFooterCommentByIdOpts.config] Override http request option.
   */
  public getFooterCommentById(
    commentId: number,
    bodyFormat?: PrimaryBodyRepresentationSingle,
    version?: number,
    includeProperties?: boolean,
    includeOperations?: boolean,
    includeLikes?: boolean,
    includeVersions?: boolean,
    includeVersion?: boolean,
    getFooterCommentByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<CreateFooterComment201Response>>;
  public getFooterCommentById(
    commentId: number,
    bodyFormat?: PrimaryBodyRepresentationSingle,
    version?: number,
    includeProperties?: boolean,
    includeOperations?: boolean,
    includeLikes?: boolean,
    includeVersions?: boolean,
    includeVersion?: boolean,
    getFooterCommentByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling getFooterCommentById.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (version !== undefined && version !== null) {
      queryParameters.append("version", <any>version);
    }
    if (includeProperties !== undefined && includeProperties !== null) {
      queryParameters.append("include-properties", <any>includeProperties);
    }
    if (includeOperations !== undefined && includeOperations !== null) {
      queryParameters.append("include-operations", <any>includeOperations);
    }
    if (includeLikes !== undefined && includeLikes !== null) {
      queryParameters.append("include-likes", <any>includeLikes);
    }
    if (includeVersions !== undefined && includeVersions !== null) {
      queryParameters.append("include-versions", <any>includeVersions);
    }
    if (includeVersion !== undefined && includeVersion !== null) {
      queryParameters.append("include-version", <any>includeVersion);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<CreateFooterComment201Response>(
          `${this.basePath}/footer-comments/${encodeURIComponent(
            String(commentId),
          )}`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getFooterCommentByIdOpts?.config,
            headers: {
              ...headers,
              ...getFooterCommentByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get children footer comments
   * Returns the children footer comments of specific comment. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
   * @param id The ID of the parent comment for which footer comment children should be returned.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getFooterCommentChildrenOpts.config] Override http request option.
   */
  public getFooterCommentChildren(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getFooterCommentChildrenOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultChildrenCommentModel>>;
  public getFooterCommentChildren(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getFooterCommentChildrenOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getFooterCommentChildren.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultChildrenCommentModel>(
          `${this.basePath}/footer-comments/${encodeURIComponent(
            String(id),
          )}/children`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getFooterCommentChildrenOpts?.config,
            headers: {
              ...headers,
              ...getFooterCommentChildrenOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get footer comments
   * Returns all footer comments. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the container and its corresponding space.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getFooterCommentsOpts.config] Override http request option.
   */
  public getFooterComments(
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getFooterCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultFooterCommentModel>>;
  public getFooterComments(
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getFooterCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultFooterCommentModel>(
          `${this.basePath}/footer-comments`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getFooterCommentsOpts?.config,
            headers: { ...headers, ...getFooterCommentsOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Get inline comment by id
   * Retrieves an inline comment by id  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space.
   * @param commentId The ID of the comment to be retrieved.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param version Allows you to retrieve a previously published version. Specify the previous version\&#39;s number to retrieve its details.
   * @param includeProperties Includes content properties associated with this inline comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeOperations Includes operations associated with this inline comment in the response, as defined in the &#x60;Operation&#x60; object. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeLikes Includes likes associated with this inline comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeVersions Includes versions associated with this inline comment in the response. The number of results will be limited to 50 and sorted in the default sort order.  A &#x60;meta&#x60; and &#x60;_links&#x60; property will be present to indicate if more results are available and a link to retrieve the rest of the results.
   * @param includeVersion Includes the current version associated with this inline comment in the response. By default this is included and can be omitted by setting the value to &#x60;false&#x60;.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getInlineCommentByIdOpts.config] Override http request option.
   */
  public getInlineCommentById(
    commentId: number,
    bodyFormat?: PrimaryBodyRepresentationSingle,
    version?: number,
    includeProperties?: boolean,
    includeOperations?: boolean,
    includeLikes?: boolean,
    includeVersions?: boolean,
    includeVersion?: boolean,
    getInlineCommentByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<CreateInlineComment201Response>>;
  public getInlineCommentById(
    commentId: number,
    bodyFormat?: PrimaryBodyRepresentationSingle,
    version?: number,
    includeProperties?: boolean,
    includeOperations?: boolean,
    includeLikes?: boolean,
    includeVersions?: boolean,
    includeVersion?: boolean,
    getInlineCommentByIdOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling getInlineCommentById.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (version !== undefined && version !== null) {
      queryParameters.append("version", <any>version);
    }
    if (includeProperties !== undefined && includeProperties !== null) {
      queryParameters.append("include-properties", <any>includeProperties);
    }
    if (includeOperations !== undefined && includeOperations !== null) {
      queryParameters.append("include-operations", <any>includeOperations);
    }
    if (includeLikes !== undefined && includeLikes !== null) {
      queryParameters.append("include-likes", <any>includeLikes);
    }
    if (includeVersions !== undefined && includeVersions !== null) {
      queryParameters.append("include-versions", <any>includeVersions);
    }
    if (includeVersion !== undefined && includeVersion !== null) {
      queryParameters.append("include-version", <any>includeVersion);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<CreateInlineComment201Response>(
          `${this.basePath}/inline-comments/${encodeURIComponent(
            String(commentId),
          )}`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getInlineCommentByIdOpts?.config,
            headers: {
              ...headers,
              ...getInlineCommentByIdOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get children inline comments
   * Returns the children inline comments of specific comment. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
   * @param id The ID of the parent comment for which inline comment children should be returned.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getInlineCommentChildrenOpts.config] Override http request option.
   */
  public getInlineCommentChildren(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getInlineCommentChildrenOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultInlineCommentChildrenModel>>;
  public getInlineCommentChildren(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getInlineCommentChildrenOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getInlineCommentChildren.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultInlineCommentChildrenModel>(
          `${this.basePath}/inline-comments/${encodeURIComponent(
            String(id),
          )}/children`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getInlineCommentChildrenOpts?.config,
            headers: {
              ...headers,
              ...getInlineCommentChildrenOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get inline comments
   * Returns all inline comments. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getInlineCommentsOpts.config] Override http request option.
   */
  public getInlineComments(
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getInlineCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultInlineCommentModel>>;
  public getInlineComments(
    bodyFormat?: PrimaryBodyRepresentation,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getInlineCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultInlineCommentModel>(
          `${this.basePath}/inline-comments`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getInlineCommentsOpts?.config,
            headers: { ...headers, ...getInlineCommentsOpts?.config?.headers },
          },
        );
      }),
    );
  }
  /**
   * Get footer comments for page
   * Returns the root footer comments of specific page. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
   * @param id The ID of the page for which footer comments should be returned.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param status Filter the footer comment being retrieved by its status.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of footer comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getPageFooterCommentsOpts.config] Override http request option.
   */
  public getPageFooterComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    status?: Array<
      "current" | "archived" | "trashed" | "deleted" | "historical" | "draft"
    >,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getPageFooterCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultPageCommentModel>>;
  public getPageFooterComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    status?: Array<
      "current" | "archived" | "trashed" | "deleted" | "historical" | "draft"
    >,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getPageFooterCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getPageFooterComments.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (status) {
      status.forEach((element) => {
        queryParameters.append("status", <any>element);
      });
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultPageCommentModel>(
          `${this.basePath}/pages/${encodeURIComponent(
            String(id),
          )}/footer-comments`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getPageFooterCommentsOpts?.config,
            headers: {
              ...headers,
              ...getPageFooterCommentsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Get inline comments for page
   * Returns the root inline comments of specific page. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
   * @param id The ID of the page for which inline comments should be returned.
   * @param bodyFormat The content format type to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
   * @param status Filter the inline comment being retrieved by its status.
   * @param resolutionStatus Filter the inline comment being retrieved by its resolution status.
   * @param sort Used to sort the result by a particular field.
   * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
   * @param limit Maximum number of inline comments per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [getPageInlineCommentsOpts.config] Override http request option.
   */
  public getPageInlineComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    status?: Array<
      "current" | "archived" | "trashed" | "deleted" | "historical" | "draft"
    >,
    resolutionStatus?: Array<"resolved" | "open" | "dangling" | "reopened">,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getPageInlineCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<MultiEntityResultPageInlineCommentModel>>;
  public getPageInlineComments(
    id: number,
    bodyFormat?: PrimaryBodyRepresentation,
    status?: Array<
      "current" | "archived" | "trashed" | "deleted" | "historical" | "draft"
    >,
    resolutionStatus?: Array<"resolved" | "open" | "dangling" | "reopened">,
    sort?: CommentSortOrder,
    cursor?: string,
    limit?: number,
    getPageInlineCommentsOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getPageInlineComments.",
      );
    }

    let queryParameters = new URLSearchParams();
    if (bodyFormat !== undefined && bodyFormat !== null) {
      queryParameters.append("body-format", <any>bodyFormat);
    }
    if (status) {
      status.forEach((element) => {
        queryParameters.append("status", <any>element);
      });
    }
    if (resolutionStatus) {
      resolutionStatus.forEach((element) => {
        queryParameters.append("resolution-status", <any>element);
      });
    }
    if (sort !== undefined && sort !== null) {
      queryParameters.append("sort", <any>sort);
    }
    if (cursor !== undefined && cursor !== null) {
      queryParameters.append("cursor", <any>cursor);
    }
    if (limit !== undefined && limit !== null) {
      queryParameters.append("limit", <any>limit);
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = [];
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.get<MultiEntityResultPageInlineCommentModel>(
          `${this.basePath}/pages/${encodeURIComponent(
            String(id),
          )}/inline-comments`,
          {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            ...getPageInlineCommentsOpts?.config,
            headers: {
              ...headers,
              ...getPageInlineCommentsOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update footer comment
   * Update a footer comment. This can be used to update the body text of a comment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
   * @param commentId The ID of the comment to be retrieved.
   * @param updateFooterCommentRequest The footer comment to be created
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateFooterCommentOpts.config] Override http request option.
   */
  public updateFooterComment(
    commentId: number,
    updateFooterCommentRequest: UpdateFooterCommentRequest,
    updateFooterCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<FooterCommentModel>>;
  public updateFooterComment(
    commentId: number,
    updateFooterCommentRequest: UpdateFooterCommentRequest,
    updateFooterCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling updateFooterComment.",
      );
    }

    if (
      updateFooterCommentRequest === null ||
      updateFooterCommentRequest === undefined
    ) {
      throw new Error(
        "Required parameter updateFooterCommentRequest was null or undefined when calling updateFooterComment.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<FooterCommentModel>(
          `${this.basePath}/footer-comments/${encodeURIComponent(
            String(commentId),
          )}`,
          updateFooterCommentRequest,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateFooterCommentOpts?.config,
            headers: {
              ...headers,
              ...updateFooterCommentOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
  /**
   * Update inline comment
   * Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
   * @param commentId The ID of the comment to be retrieved.
   * @param updateInlineCommentModel The inline comment to be updated
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   * @param {*} [updateInlineCommentOpts.config] Override http request option.
   */
  public updateInlineComment(
    commentId: number,
    updateInlineCommentModel: UpdateInlineCommentModel,
    updateInlineCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<AxiosResponse<CreateInlineComment201Response>>;
  public updateInlineComment(
    commentId: number,
    updateInlineCommentModel: UpdateInlineCommentModel,
    updateInlineCommentOpts?: { config?: AxiosRequestConfig },
  ): Observable<any> {
    if (commentId === null || commentId === undefined) {
      throw new Error(
        "Required parameter commentId was null or undefined when calling updateInlineComment.",
      );
    }

    if (
      updateInlineCommentModel === null ||
      updateInlineCommentModel === undefined
    ) {
      throw new Error(
        "Required parameter updateInlineCommentModel was null or undefined when calling updateInlineComment.",
      );
    }

    let headers = { ...this.defaultHeaders };

    let accessTokenObservable: Observable<any> = of(null);

    // authentication (basicAuth) required
    if (this.configuration.username || this.configuration.password) {
      headers["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }

    // authentication (oAuthDefinitions) required
    if (this.configuration.accessToken) {
      accessTokenObservable =
        typeof this.configuration.accessToken === "function"
          ? from(Promise.resolve(this.configuration.accessToken()))
          : from(Promise.resolve(this.configuration.accessToken));
    }

    // to determine the Accept header
    let httpHeaderAccepts: string[] = ["application/json"];
    const httpHeaderAcceptSelected: string | undefined =
      this.configuration.selectHeaderAccept(httpHeaderAccepts);
    if (httpHeaderAcceptSelected != undefined) {
      headers["Accept"] = httpHeaderAcceptSelected;
    }

    // to determine the Content-Type header
    const consumes: string[] = ["application/json"];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected != undefined) {
      headers["Content-Type"] = httpContentTypeSelected;
    }
    return accessTokenObservable.pipe(
      switchMap((accessToken) => {
        if (accessToken) {
          headers["Authorization"] = `Bearer ${accessToken}`;
        }

        return this.httpClient.put<CreateInlineComment201Response>(
          `${this.basePath}/inline-comments/${encodeURIComponent(
            String(commentId),
          )}`,
          updateInlineCommentModel,
          {
            withCredentials: this.configuration.withCredentials,
            ...updateInlineCommentOpts?.config,
            headers: {
              ...headers,
              ...updateInlineCommentOpts?.config?.headers,
            },
          },
        );
      }),
    );
  }
}
