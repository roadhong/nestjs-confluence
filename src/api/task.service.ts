/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Injectable, Optional } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import type { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Observable, from, of, switchMap } from 'rxjs';
import { MultiEntityResultTask } from '../model/multiEntityResultTask';
import { PrimaryBodyRepresentation } from '../model/primaryBodyRepresentation';
import { Task } from '../model/task';
import { UpdateTaskRequest } from '../model/updateTaskRequest';
import { Configuration } from '../configuration';
import { COLLECTION_FORMATS } from '../variables';


@Injectable()
export class TaskService {

    protected basePath = 'https://no-default/wiki/api/v2';
    public defaultHeaders: Record<string,string> = {};
    public configuration = new Configuration();
    protected httpClient: HttpService;

    constructor(httpClient: HttpService, @Optional() configuration: Configuration) {
        this.configuration = configuration || this.configuration;
        this.basePath = configuration?.basePath || this.basePath;
        this.httpClient = configuration?.httpClient || httpClient;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        return consumes.includes(form);
    }

    /**
     * Get task by id
     * Returns a specific task.   **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the containing page or blog post and its corresponding space.
     * @param id The ID of the task to be returned. If you don\&#39;t know the task ID, use Get tasks and filter the results.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getTaskByIdOpts.config] Override http request option.
     */
    public getTaskById(id: number, bodyFormat?: PrimaryBodyRepresentation, getTaskByIdOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Task>>;
    public getTaskById(id: number, bodyFormat?: PrimaryBodyRepresentation, getTaskByIdOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTaskById.');
        }

        let queryParameters = new URLSearchParams();
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<Task>(`${this.basePath}/tasks/${encodeURIComponent(String(id))}`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getTaskByIdOpts?.config,
                        headers: {...headers, ...getTaskByIdOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Get tasks
     * Returns all tasks. The number of results is limited by the &#x60;limit&#x60; parameter and additional results (if available) will be available through the &#x60;next&#x60; URL present in the &#x60;Link&#x60; response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\&#39;Can use\&#39; global permission). Only tasks that the user has permission to view will be returned.
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
     * @param includeBlankTasks Specifies whether to include blank tasks in the response. Defaults to &#x60;true&#x60;.
     * @param status Filters on the status of the task.
     * @param taskId Filters on task ID. Multiple IDs can be specified.
     * @param spaceId Filters on the space ID of the task. Multiple IDs can be specified.
     * @param pageId Filters on the page ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.
     * @param blogpostId Filters on the blog post ID of the task. Multiple IDs can be specified. Note - page and blog post filters can be used in conjunction.
     * @param createdBy Filters on the Account ID of the user who created this task. Multiple IDs can be specified.
     * @param assignedTo Filters on the Account ID of the user to whom this task is assigned. Multiple IDs can be specified.
     * @param completedBy Filters on the Account ID of the user who completed this task. Multiple IDs can be specified.
     * @param createdAtFrom Filters on start of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.
     * @param createdAtTo Filters on end of date-time range of task based on creation date (inclusive). Input is epoch time in milliseconds.
     * @param dueAtFrom Filters on start of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.
     * @param dueAtTo Filters on end of date-time range of task based on due date (inclusive). Input is epoch time in milliseconds.
     * @param completedAtFrom Filters on start of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.
     * @param completedAtTo Filters on end of date-time range of task based on completion date (inclusive). Input is epoch time in milliseconds.
     * @param cursor Used for pagination, this opaque cursor will be returned in the &#x60;next&#x60; URL in the &#x60;Link&#x60; response header. Use the relative URL in the &#x60;Link&#x60; header to retrieve the &#x60;next&#x60; set of results.
     * @param limit Maximum number of tasks per result to return. If more results exist, use the &#x60;Link&#x60; header to retrieve a relative URL that will return the next set of results.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [getTasksOpts.config] Override http request option.
     */
    public getTasks(bodyFormat?: PrimaryBodyRepresentation, includeBlankTasks?: boolean, status?: 'complete' | 'incomplete', taskId?: Array<number>, spaceId?: Array<number>, pageId?: Array<number>, blogpostId?: Array<number>, createdBy?: Array<string>, assignedTo?: Array<string>, completedBy?: Array<string>, createdAtFrom?: number, createdAtTo?: number, dueAtFrom?: number, dueAtTo?: number, completedAtFrom?: number, completedAtTo?: number, cursor?: string, limit?: number, getTasksOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<MultiEntityResultTask>>;
    public getTasks(bodyFormat?: PrimaryBodyRepresentation, includeBlankTasks?: boolean, status?: 'complete' | 'incomplete', taskId?: Array<number>, spaceId?: Array<number>, pageId?: Array<number>, blogpostId?: Array<number>, createdBy?: Array<string>, assignedTo?: Array<string>, completedBy?: Array<string>, createdAtFrom?: number, createdAtTo?: number, dueAtFrom?: number, dueAtTo?: number, completedAtFrom?: number, completedAtTo?: number, cursor?: string, limit?: number, getTasksOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        let queryParameters = new URLSearchParams();
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }
        if (includeBlankTasks !== undefined && includeBlankTasks !== null) {
            queryParameters.append('include-blank-tasks', <any>includeBlankTasks);
        }
        if (status !== undefined && status !== null) {
            queryParameters.append('status', <any>status);
        }
        if (taskId) {
            taskId.forEach((element) => {
                queryParameters.append('task-id', <any>element);
            })
        }
        if (spaceId) {
            spaceId.forEach((element) => {
                queryParameters.append('space-id', <any>element);
            })
        }
        if (pageId) {
            pageId.forEach((element) => {
                queryParameters.append('page-id', <any>element);
            })
        }
        if (blogpostId) {
            blogpostId.forEach((element) => {
                queryParameters.append('blogpost-id', <any>element);
            })
        }
        if (createdBy) {
            createdBy.forEach((element) => {
                queryParameters.append('created-by', <any>element);
            })
        }
        if (assignedTo) {
            assignedTo.forEach((element) => {
                queryParameters.append('assigned-to', <any>element);
            })
        }
        if (completedBy) {
            completedBy.forEach((element) => {
                queryParameters.append('completed-by', <any>element);
            })
        }
        if (createdAtFrom !== undefined && createdAtFrom !== null) {
            queryParameters.append('created-at-from', <any>createdAtFrom);
        }
        if (createdAtTo !== undefined && createdAtTo !== null) {
            queryParameters.append('created-at-to', <any>createdAtTo);
        }
        if (dueAtFrom !== undefined && dueAtFrom !== null) {
            queryParameters.append('due-at-from', <any>dueAtFrom);
        }
        if (dueAtTo !== undefined && dueAtTo !== null) {
            queryParameters.append('due-at-to', <any>dueAtTo);
        }
        if (completedAtFrom !== undefined && completedAtFrom !== null) {
            queryParameters.append('completed-at-from', <any>completedAtFrom);
        }
        if (completedAtTo !== undefined && completedAtTo !== null) {
            queryParameters.append('completed-at-to', <any>completedAtTo);
        }
        if (cursor !== undefined && cursor !== null) {
            queryParameters.append('cursor', <any>cursor);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters.append('limit', <any>limit);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.get<MultiEntityResultTask>(`${this.basePath}/tasks`,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...getTasksOpts?.config,
                        headers: {...headers, ...getTasksOpts?.config?.headers},
                    }
                );
            })
        );
    }
    /**
     * Update task
     * Update a task by id. This endpoint currently only supports updating task status.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to edit the containing page or blog post and view its corresponding space.
     * @param id The ID of the task to be updated. If you don\&#39;t know the task ID, use Get tasks and filter the results.
     * @param updateTaskRequest 
     * @param bodyFormat The content format types to be returned in the &#x60;body&#x60; field of the response. If available, the representation will be available under a response field of the same name under the &#x60;body&#x60; field.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param {*} [updateTaskOpts.config] Override http request option.
     */
    public updateTask(id: number, updateTaskRequest: UpdateTaskRequest, bodyFormat?: PrimaryBodyRepresentation, updateTaskOpts?: { config?: AxiosRequestConfig }): Observable<AxiosResponse<Task>>;
    public updateTask(id: number, updateTaskRequest: UpdateTaskRequest, bodyFormat?: PrimaryBodyRepresentation, updateTaskOpts?: { config?: AxiosRequestConfig }): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTask.');
        }

        if (updateTaskRequest === null || updateTaskRequest === undefined) {
            throw new Error('Required parameter updateTaskRequest was null or undefined when calling updateTask.');
        }

        let queryParameters = new URLSearchParams();
        if (bodyFormat !== undefined && bodyFormat !== null) {
            queryParameters.append('body-format', <any>bodyFormat);
        }

        let headers = {...this.defaultHeaders};

        let accessTokenObservable: Observable<any> = of(null);

        // authentication (basicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers['Authorization'] = 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
        }

        // authentication (oAuthDefinitions) required
        if (this.configuration.accessToken) {
            accessTokenObservable = typeof this.configuration.accessToken === 'function'
                ? from(Promise.resolve(this.configuration.accessToken()))
                : from(Promise.resolve(this.configuration.accessToken))
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers['Accept'] = httpHeaderAcceptSelected;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers['Content-Type'] = httpContentTypeSelected;
        }
        return accessTokenObservable.pipe(
            switchMap((accessToken) => {
                if (accessToken) {
                    headers['Authorization'] = `Bearer ${accessToken}`;
                }

                return this.httpClient.put<Task>(`${this.basePath}/tasks/${encodeURIComponent(String(id))}`,
                    updateTaskRequest,
                    {
                        params: queryParameters,
                        withCredentials: this.configuration.withCredentials,
                        ...updateTaskOpts?.config,
                        headers: {...headers, ...updateTaskOpts?.config?.headers},
                    }
                );
            })
        );
    }
}
